/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

use std::collections::{HashMap, HashSet};
use std::sync::Arc;

use cedar_policy_core::ast::{
    Context, Eid, Entity, EntityType, EntityUID, InternalName, Name, Request, RestrictedExpr,
};
use cedar_policy_core::entities::Entities;
use cedar_policy_core::validator::ValidatorSchema;

use chrono::{DateTime, NaiveDate, NaiveDateTime, TimeZone, Utc};

use super::identifiers;
use crate::{RequestGeneratorError, SchemaGeneratorConfig};

use mcp_tools_sdk::data::{Input, Output, TypedValue};
use mcp_tools_sdk::description::ServerDescription;
use smol_str::{SmolStr, ToSmolStr};

#[derive(Clone, Debug)]
/// A `RequestGenerator` is a structure produced by a `SchemaGenerator` which allows
/// a user to generator Cedar Requests that are valid for the Schema generated by the
/// `SchemaGenerator`.
pub struct RequestGenerator {
    config: SchemaGeneratorConfig,
    tools: ServerDescription,
    root_namespace: Option<Name>,
    schema: ValidatorSchema,
}

impl RequestGenerator {
    pub(crate) fn new(
        config: SchemaGeneratorConfig,
        tools: ServerDescription,
        root_namespace: Option<Name>,
        schema: ValidatorSchema,
    ) -> Self {
        Self {
            config,
            tools,
            root_namespace,
            schema,
        }
    }

    /// Generate an authorization request & entities necessary to call the Cedar authorization engine.
    /// A user of this function is expected to provide
    /// (1) the principal and resource of the request
    /// (2) any common context elements
    /// (3) any entity information for the principal, resource, and common context
    /// (4) the MCP tool input request, and (5) optionally the MCP tool output response
    ///
    /// The function will then return a Cedar Request and entities necessary to determine if the principal is
    /// authorized to use (or receive the oputout of) the requested tool.
    pub fn generate_request(
        &self,
        principal: EntityUID,
        resource: EntityUID,
        context: impl IntoIterator<Item = (SmolStr, RestrictedExpr)>,
        mut entities: Entities,
        input: &Input,
        output: Option<&Output>,
    ) -> Result<(Request, Entities), RequestGeneratorError> {
        let input = self.tools.validate_input(input)?;
        // PANIC SAFETY: `self.tools` must contain a tool named `input.name()` and `input` validates against `tool`
        #[allow(
            clippy::unwrap_used,
            reason = "Validation ensures there is a tool in with the same name that the input validates against"
        )]
        let tool = self
            .tools
            .tool_descriptions()
            .find(|t| t.name() == input.name())
            .unwrap();

        let output = output
            .map(|output| self.tools.validate_output(tool.name(), output))
            .transpose()?;

        let mut type_defs = self
            .tools
            .type_definitions()
            .map(|ty_def| (ty_def.name().to_smolstr(), self.root_namespace.clone()))
            .collect::<HashMap<_, _>>();

        let tool_ns: Name = tool.name().parse()?;
        let tool_ns = tool_ns.qualify_with_name(self.root_namespace.as_ref());

        // collect all of the tool specific type defs
        type_defs.extend(
            tool.type_definitions()
                .map(|ty_def| (ty_def.name().to_smolstr(), Some(tool_ns.clone()))),
        );

        let input_ns = identifiers::INPUT_NAME.qualify_with_name(Some(&tool_ns));

        // Combine server / tool / input specific type defs
        let mut inputs_type_defs = type_defs.clone();
        inputs_type_defs.extend(
            tool.inputs()
                .type_definitions()
                .map(|ty_def| (ty_def.name().to_smolstr(), Some(input_ns.clone()))),
        );

        let mut inputs = HashMap::new();
        for (name, arg) in input.get_args() {
            let (expr, new_entities) =
                self.val_to_cedar(arg, &inputs_type_defs, Some(&input_ns), name)?;
            entities = entities.add_entities(
                new_entities.into_iter().map(Arc::from),
                None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                cedar_policy_core::extensions::Extensions::all_available(),
            )?;
            inputs.insert(name.to_smolstr(), expr);
        }
        let inputs = RestrictedExpr::record(inputs)?;

        let context = match &output {
            Some(output) if self.config.include_outputs => {
                let output_ns = identifiers::OUTPUT_NAME.qualify_with_name(Some(&tool_ns));

                // Combine server / tool / output specific type defs
                let mut outputputs_type_defs = type_defs.clone();
                outputputs_type_defs.extend(
                    tool.outputs()
                        .type_definitions()
                        .map(|ty_def| (ty_def.name().to_smolstr(), Some(output_ns.clone()))),
                );
                let mut outputs = HashMap::new();
                for (name, res) in output.get_results() {
                    let (expr, new_entities) =
                        self.val_to_cedar(res, &outputputs_type_defs, Some(&output_ns), name)?;
                    entities = entities.add_entities(
                        new_entities.into_iter().map(Arc::from),
                        None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                        cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                        cedar_policy_core::extensions::Extensions::all_available(),
                    )?;
                    outputs.insert(name.to_smolstr(), expr);
                }
                let outputs = RestrictedExpr::record(outputs)?;
                context.into_iter().chain(vec![
                    ("input".to_smolstr(), inputs),
                    ("output".to_smolstr(), outputs),
                ])
            }
            _ => context
                .into_iter()
                .chain(vec![("input".to_smolstr(), inputs)]),
        };
        let context = Context::from_pairs(
            context,
            cedar_policy_core::extensions::Extensions::all_available(),
        )?;

        let action_name = Eid::new(tool.name());
        let action = EntityUID::from_components(
            identifiers::ACTION.qualify_with(self.root_namespace.as_ref()),
            action_name,
            None,
        );
        // Create final request and pass schema to force validation of request
        // By validating we ensure tht the provided principal, resource, and common contexts
        // provided by the user actually match the generated schema
        let request = Request::new(
            (principal, None),
            (action, None),
            (resource, None),
            context,
            Some(&self.schema),
            cedar_policy_core::extensions::Extensions::all_available(),
        )?;

        Ok((request, entities))
    }

    fn val_to_cedar(
        &self,
        val: &TypedValue,
        type_defs: &HashMap<SmolStr, Option<Name>>,
        namespace: Option<&Name>,
        ty_name: &str,
    ) -> Result<(RestrictedExpr, Entities), RequestGeneratorError> {
        match val {
            TypedValue::Null => {
                let ty = EntityType::from(Name::from(identifiers::NULL_TYPE.clone()));
                let ty = ty.qualify_with(self.root_namespace.as_ref());
                let eid = Eid::new("null");
                let euid = EntityUID::from_components(ty, eid, None);
                Ok((RestrictedExpr::val(euid), Entities::new()))
            }
            TypedValue::Bool(b) => Ok((RestrictedExpr::val(*b), Entities::new())),
            TypedValue::Integer(i) => Ok((RestrictedExpr::val(*i), Entities::new())),
            TypedValue::Float(f) => {
                if self.config.numbers_as_decimal {
                    let val = RestrictedExpr::val(format!("{:.4}", f));
                    Ok((
                        RestrictedExpr::call_extension_fn(
                            identifiers::DECIMAL_CTOR.clone(),
                            vec![val],
                        ),
                        Entities::new(),
                    ))
                } else {
                    let ty = EntityType::from(Name::from(identifiers::FLOAT_TYPE.clone()));
                    let ty = ty.qualify_with(self.root_namespace.as_ref());
                    let eid = Eid::new(format!("{}", f));
                    let euid = EntityUID::from_components(ty, eid, None);
                    Ok((RestrictedExpr::val(euid), Entities::new()))
                }
            }
            TypedValue::Number(n) => {
                if self.config.numbers_as_decimal {
                    let val = match (n.to_f64(), n.to_i64()) {
                        (Some(f), _) => format!("{:.4}", f),
                        (_, Some(i)) => format!("{}.0", i),
                        _ => {
                            return Err(RequestGeneratorError::MalformedDecimalNumber(
                                n.as_str().into(),
                            ));
                        }
                    };
                    let val = RestrictedExpr::val(val);
                    Ok((
                        RestrictedExpr::call_extension_fn(
                            identifiers::DECIMAL_CTOR.clone(),
                            vec![val],
                        ),
                        Entities::new(),
                    ))
                } else {
                    let ty = EntityType::from(Name::from(identifiers::NUMBER_TYPE.clone()));
                    let ty = ty.qualify_with(self.root_namespace.as_ref());
                    let eid = Eid::new(n.as_str());
                    let euid = EntityUID::from_components(ty, eid, None);
                    Ok((RestrictedExpr::val(euid), Entities::new()))
                }
            }
            TypedValue::String(s) => Ok((RestrictedExpr::val(s.as_str()), Entities::new())),
            TypedValue::Decimal(s) => {
                let val = RestrictedExpr::val(s.as_str());
                Ok((
                    RestrictedExpr::call_extension_fn(identifiers::DECIMAL_CTOR.clone(), vec![val]),
                    Entities::new(),
                ))
            }
            TypedValue::Datetime(s) => {
                let val = RestrictedExpr::val(reformat_datestr(s.as_str()));
                Ok((
                    RestrictedExpr::call_extension_fn(
                        identifiers::DATETIME_CTOR.clone(),
                        vec![val],
                    ),
                    Entities::new(),
                ))
            }
            TypedValue::Duration(s) => {
                let val = RestrictedExpr::val(reformat_duration(s.as_str()));
                Ok((
                    RestrictedExpr::call_extension_fn(
                        identifiers::DURATION_CTOR.clone(),
                        vec![val],
                    ),
                    Entities::new(),
                ))
            }
            TypedValue::IpAddr(s) => {
                let val = RestrictedExpr::val(reformat_ipaddr(s.as_str()));
                Ok((
                    RestrictedExpr::call_extension_fn(identifiers::IPADDR_CTOR.clone(), vec![val]),
                    Entities::new(),
                ))
            }
            TypedValue::Unknown(_) => {
                let ty = EntityType::from(Name::from(identifiers::UNKNOWN_TYPE.clone()));
                let ty = ty.qualify_with(self.root_namespace.as_ref());
                let eid = Eid::new("unknown");
                let euid = EntityUID::from_components(ty, eid, None);
                Ok((RestrictedExpr::val(euid), Entities::new()))
            }
            TypedValue::Enum(s) => {
                let ty: EntityType = ty_name.parse()?;
                let ty = ty.qualify_with(namespace);
                let eid = Eid::new(s.as_str());
                let euid = EntityUID::from_components(ty, eid, None);
                let euid = if self.config.flatten_namespaces {
                    flatten_name(euid)
                } else {
                    euid
                };
                Ok((RestrictedExpr::val(euid), Entities::new()))
            }
            TypedValue::Array(vals) => {
                let mut exprs = Vec::new();
                let mut entities = Entities::new();
                for val in vals {
                    let (expr, new_entities) =
                        self.val_to_cedar(val, type_defs, namespace, ty_name)?;
                    entities = entities.add_entities(
                        new_entities.into_iter().map(Arc::from),
                        None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                        cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                        cedar_policy_core::extensions::Extensions::all_available(),
                    )?;
                    exprs.push(expr);
                }
                Ok((RestrictedExpr::set(exprs), entities))
            }
            TypedValue::Tuple(vals) => {
                let mut pairs = HashMap::new();
                let mut entities = Entities::new();
                for (i, val) in vals.iter().enumerate() {
                    let sub_ty_name = format!("Proj{i}");
                    let name = format!("proj{i}").to_smolstr();
                    let sub_namespace: Name = ty_name.parse()?;
                    let sub_namespace = sub_namespace.qualify_with_name(namespace);
                    let (expr, new_entities) =
                        self.val_to_cedar(val, type_defs, Some(&sub_namespace), &sub_ty_name)?;
                    entities = entities.add_entities(
                        new_entities.into_iter().map(Arc::from),
                        None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                        cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                        cedar_policy_core::extensions::Extensions::all_available(),
                    )?;
                    pairs.insert(name, expr);
                }
                Ok((RestrictedExpr::record(pairs)?, entities))
            }
            TypedValue::Union { index, value } => {
                let sub_ty_name = format!("TypeChoice{}", index);
                let name = format!("typeChoice{}", index).to_smolstr();
                let sub_namespace: Name = ty_name.parse()?;
                let sub_namespace = sub_namespace.qualify_with_name(namespace);
                let (expr, entities) =
                    self.val_to_cedar(value, type_defs, Some(&sub_namespace), &sub_ty_name)?;
                Ok((RestrictedExpr::record([(name, expr)])?, entities))
            }
            TypedValue::Object {
                properties,
                additional_properties,
            } => {
                let sub_namespace: Name = ty_name.parse()?;
                let sub_namespace = sub_namespace.qualify_with_name(namespace);

                let mut entities = Entities::new();
                let into_pairs = |props: &HashMap<SmolStr, TypedValue>,
                                  entities: &mut Entities|
                 -> Result<
                    HashMap<SmolStr, RestrictedExpr>,
                    RequestGeneratorError,
                > {
                    let mut pairs = HashMap::new();
                    for (name, val) in props.iter() {
                        let (expr, new_entities) =
                            self.val_to_cedar(val, type_defs, Some(&sub_namespace), name.as_ref())?;
                        let old_entities = std::mem::replace(entities, Entities::new());
                        *entities = old_entities.add_entities(
                            new_entities.into_iter().map(Arc::from),
                            None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                            cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                            cedar_policy_core::extensions::Extensions::all_available(),
                        )?;
                        pairs.insert(name.clone(), expr);
                    }
                    Ok(pairs)
                };

                let pairs = into_pairs(properties, &mut entities)?;
                let tags = into_pairs(additional_properties, &mut entities)?;

                if tags.is_empty() && self.config.objects_as_records {
                    Ok((RestrictedExpr::record(pairs.into_iter())?, entities))
                } else {
                    let entity_ty: EntityType = ty_name.parse()?;
                    let entity_ty = entity_ty.qualify_with(namespace);
                    let eid = Eid::new("");
                    let euid = EntityUID::from_components(entity_ty, eid, None);
                    let euid = if self.config.flatten_namespaces {
                        flatten_name(euid)
                    } else {
                        euid
                    };
                    let entity = Entity::new(
                        euid.clone(),
                        pairs,
                        HashSet::new(),
                        HashSet::new(),
                        tags,
                        cedar_policy_core::extensions::Extensions::all_available(),
                    )?;
                    entities = entities.add_entities(
                        [Arc::from(entity)],
                        None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                        cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                        cedar_policy_core::extensions::Extensions::all_available(),
                    )?;
                    Ok((RestrictedExpr::val(euid), entities))
                }
            }
            TypedValue::Ref { name, val } => match type_defs.get(name) {
                None => {
                    let ns = match namespace {
                        None => "".into(),
                        Some(name) => format!("{}", name),
                    };
                    Err(RequestGeneratorError::undefined_ref(name.to_string(), ns))
                }
                Some(ns) => self.val_to_cedar(val, type_defs, ns.as_ref(), name.as_str()),
            },
        }
    }
}

// PANIC SAFETY: The input `str` should have been validated as a date-time str, and should parse
#[allow(clippy::unreachable)]
/// This function converts from JSON date or date-time formatted strings to Cedar datetime strings.
/// This conversion uses chrono library to parse and reformat the strings appropriately.
///
/// Note: this function loses sub-millisecond precision
fn reformat_datestr(str: &str) -> String {
    // Try parsing as date only (YYYY-MM-DD)
    if let Ok(date) = NaiveDate::parse_from_str(str, "%Y-%m-%d") {
        return date.format("%Y-%m-%d").to_string();
    }

    // Try parsing as RFC3339 (with timezone)
    if let Ok(dt) = DateTime::parse_from_rfc3339(str) {
        let dt_utc = dt.with_timezone(&Utc);

        // Check if it has subsecond precision
        if dt_utc.timestamp_subsec_millis() > 0 {
            // With milliseconds
            if dt.offset().local_minus_utc() == 0 {
                // UTC with milliseconds: YYYY-MM-DDTHH:MM:SS.sssZ
                return dt_utc.format("%Y-%m-%dT%H:%M:%S%.3fZ").to_string();
            } else {
                // With timezone offset and milliseconds: YYYY-MM-DDTHH:MM:SS.sss+0100
                return dt.format("%Y-%m-%dT%H:%M:%S%.3f%z").to_string();
            }
        } else {
            // Without milliseconds
            if dt.offset().local_minus_utc() == 0 {
                // UTC: YYYY-MM-DDTHH:MM:SSZ
                return dt_utc.format("%Y-%m-%dT%H:%M:%SZ").to_string();
            } else {
                // With timezone offset: YYYY-MM-DDTHH:MM:SS+0100
                return dt.format("%Y-%m-%dT%H:%M:%S%z").to_string();
            }
        }
    }

    // Try parsing with basic timezone format
    if let Ok(dt) = DateTime::parse_from_str(str, "%Y-%m-%dT%H:%M:%S%z") {
        let dt_utc = dt.with_timezone(&Utc);

        if dt_utc.timestamp_subsec_millis() > 0 {
            if dt.offset().local_minus_utc() == 0 {
                return dt_utc.format("%Y-%m-%dT%H:%M:%S%.3fZ").to_string();
            } else {
                return dt.format("%Y-%m-%dT%H:%M:%S%.3f%z").to_string();
            }
        } else if dt.offset().local_minus_utc() == 0 {
            return dt_utc.format("%Y-%m-%dT%H:%M:%SZ").to_string();
        } else {
            return dt.format("%Y-%m-%dT%H:%M:%S%z").to_string();
        }
    }

    // Try parsing with basic timezone format WITH fractional seconds
    if let Ok(dt) = DateTime::parse_from_str(str, "%Y-%m-%dT%H:%M:%S%.f%z") {
        let dt_utc = dt.with_timezone(&Utc);

        if dt_utc.timestamp_subsec_millis() > 0 {
            if dt.offset().local_minus_utc() == 0 {
                return dt_utc.format("%Y-%m-%dT%H:%M:%S%.3fZ").to_string();
            } else {
                return dt.format("%Y-%m-%dT%H:%M:%S%.3f%z").to_string();
            }
        } else if dt.offset().local_minus_utc() == 0 {
            return dt_utc.format("%Y-%m-%dT%H:%M:%SZ").to_string();
        } else {
            return dt.format("%Y-%m-%dT%H:%M:%S%z").to_string();
        }
    }

    // Try parsing as naive datetime (no timezone)
    if let Ok(ndt) = NaiveDateTime::parse_from_str(str, "%Y-%m-%dT%H:%M:%S%.f") {
        // Convert to UTC (assuming input is UTC)
        let dt_utc = Utc.from_utc_datetime(&ndt);

        // Check if it has subsecond precision
        if dt_utc.timestamp_subsec_millis() > 0 {
            // UTC with milliseconds: YYYY-MM-DDTHH:MM:SS.sssZ
            return dt_utc.format("%Y-%m-%dT%H:%M:%S%.3fZ").to_string();
        } else {
            // UTC without milliseconds: YYYY-MM-DDTHH:MM:SSZ
            return dt_utc.format("%Y-%m-%dT%H:%M:%SZ").to_string();
        }
    }

    unreachable!("Validated DatetimeStrings should be parsable")
}

/// This function converts from the iso8601 standard for Duration (JSON duration formatted strings) into
/// cedar formatted durations. Unfortunately, iso8601 uses calendar based durations, and Cedar uses fixed
/// time durations. This means that the best we can do for converting iso8601 durations that contain
/// months or year components is to approximate (e.g., 1 year = 365 days and 1 month = 30 days).
fn reformat_duration(str: &str) -> String {
    // PANIC SAFETY: validation ensures that the input `str` will parse as an `iso8601::Duration`
    #[allow(clippy::unwrap_used)]
    let duration = iso8601::duration(str).unwrap();

    match duration {
        iso8601::Duration::YMDHMS {
            year,
            month,
            day,
            hour,
            minute,
            second,
            millisecond,
        } => {
            // APPROXIMATE year & month into number of days
            let n_days = year * 365 + month * 30 + day;
            let mut ret = "".to_string();
            if n_days != 0 {
                ret = format!("{}{}d", ret, n_days)
            }
            if hour != 0 {
                ret = format!("{}{}h", ret, hour)
            }
            if minute != 0 {
                ret = format!("{}{}m", ret, minute)
            }
            if second != 0 {
                ret = format!("{}{}s", ret, second)
            }
            if millisecond != 0 || ret.is_empty() {
                ret = format!("{}{}ms", ret, millisecond)
            }
            ret
        }
        iso8601::Duration::Weeks(weeks) => {
            let n_days = 7 * weeks;
            format!("{}d", n_days)
        }
    }
}

/// This function converts from JSON compliant ipv4 and ipv6 formatted strings (which can be parsed by `std::net::IpAddr`)
/// to Cedar compliant IpAddr strings (which requires a stricter formatting, e.g., no leading 0s).
/// This is accomplished by passing through Rust's IpAddr type which allows lax formatting during deserialization and stricter formatting
/// during serialization to string.
fn reformat_ipaddr(str: &str) -> String {
    // PANIC SAFETY: validation ensures that the input `str` will parse as an `IpAddr` or `IpNet`
    #[allow(clippy::unwrap_used)]
    str.parse::<std::net::IpAddr>()
        .map(|ip| {
            // Convert IPv4-mapped IPv6 to IPv4
            match ip {
                std::net::IpAddr::V6(v6) => {
                    if let Some(ipv4) = v6.to_ipv4_mapped() {
                        std::net::IpAddr::V4(ipv4).to_string()
                    } else {
                        ip.to_string()
                    }
                }
                std::net::IpAddr::V4(_) => ip.to_string(),
            }
        })
        .unwrap_or_else(|_| {
            str.parse::<ipnet::IpNet>()
                .map(|ipnet| {
                    // Handle IpNet case - convert if it's IPv4-mapped
                    match ipnet.addr() {
                        std::net::IpAddr::V6(v6) => {
                            if let Some(ipv4) = v6.to_ipv4_mapped() {
                                // Reconstruct with IPv4 and original prefix length
                                format!("{}/{}", ipv4, ipnet.prefix_len())
                            } else {
                                ipnet.to_string()
                            }
                        }
                        std::net::IpAddr::V4(_) => ipnet.to_string(),
                    }
                })
                .unwrap()
        })
}

// PANIC SAFETY: the input EntityUID is valid. Transforming to flatten the entity type name should be safe
#[allow(clippy::unwrap_used)]
/// Flatten an EntityUID's typename to be consistent with the transformation used in Schema generator when flatten_namespaces
/// configuration option is set to true. That transformation transforms a name `TopLevelNamespace::Other::Name::Spaces::BaseName`
/// into the name `TopLevelNameSpace::Other_Name_Spaces_BaseName`.
fn flatten_name(euid: EntityUID) -> EntityUID {
    let (entity_type, eid) = euid.components();
    let entity_type = entity_type.name().qualify_with(None);
    let mut parts = entity_type.namespace_components().cloned();
    let flattened_namespace = parts
        .next()
        .map(InternalName::from)
        .map(Name::try_from)
        .transpose()
        .unwrap();
    let flattened_basename = parts.map(|id| id.to_string()).collect::<Vec<_>>().join("_");
    let entity_type: EntityType = flattened_basename.parse().unwrap();
    let entity_type = entity_type.qualify_with(flattened_namespace.as_ref());
    EntityUID::from_components(entity_type, eid, None)
}

#[cfg(test)]
mod test {
    use std::str::FromStr;

    use super::*;

    fn test_reformat_datetime_passes_cedar(input: &str, expected: &str) {
        assert_eq!(reformat_datestr(input), expected);
        let expr: RestrictedExpr = format!("datetime(\"{}\")", expected)
            .parse()
            .expect(&format!(
                "reformat_datestr({}) == {}, but datetime(\"{}\") does not parse in Cedar",
                input, expected, expected
            ));
        let entities = Entities::new();
        let evaluator = cedar_policy_core::evaluator::Evaluator::new(
            cedar_policy_core::ast::Request::new(
                (EntityUID::from_str("P::\"\"").unwrap(), None),
                (EntityUID::from_str("Action::\"\"").unwrap(), None),
                (EntityUID::from_str("R::\"\"").unwrap(), None),
                Context::empty(),
                None::<&ValidatorSchema>,
                cedar_policy_core::extensions::Extensions::all_available(),
            )
            .unwrap(),
            &entities,
            cedar_policy_core::extensions::Extensions::all_available(),
        );
        evaluator.interpret(&expr, &HashMap::new()).expect(&format!(
            "reformat_datestr({}) == {}, but datetime(\"{}\") evaluates to an error in Cedar",
            input, expected, expected
        ));
    }

    #[test]
    fn test_reformat_datetime_str() {
        // Date Only (YYYY-MM-DD)
        test_reformat_datetime_passes_cedar("2025-12-11", "2025-12-11");
        test_reformat_datetime_passes_cedar("2024-01-01", "2024-01-01");
        test_reformat_datetime_passes_cedar("2024-12-31", "2024-12-31");
        test_reformat_datetime_passes_cedar("2024-02-29", "2024-02-29");
        test_reformat_datetime_passes_cedar("2023-02-28", "2023-02-28");
        test_reformat_datetime_passes_cedar("1970-01-01", "1970-01-01");
        test_reformat_datetime_passes_cedar("2099-12-31", "2099-12-31");

        // DateTime UTC (RFC3339,
        test_reformat_datetime_passes_cedar("2025-12-11T15:26:41Z", "2025-12-11T15:26:41Z");
        test_reformat_datetime_passes_cedar("2024-01-01T00:00:00Z", "2024-01-01T00:00:00Z");
        test_reformat_datetime_passes_cedar("2024-12-31T23:59:59Z", "2024-12-31T23:59:59Z");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45Z", "2024-06-15T12:30:45Z");
        test_reformat_datetime_passes_cedar("1970-01-01T00:00:00Z", "1970-01-01T00:00:00Z");

        // DateTime with Milliseconds UTC
        test_reformat_datetime_passes_cedar("2025-12-11T15:26:41.123Z", "2025-12-11T15:26:41.123Z");
        test_reformat_datetime_passes_cedar("2024-12-31T23:59:59.999Z", "2024-12-31T23:59:59.999Z");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45.500Z", "2024-06-15T12:30:45.500Z");
        test_reformat_datetime_passes_cedar("2024-03-20T08:15:30.001Z", "2024-03-20T08:15:30.001Z");
        test_reformat_datetime_passes_cedar("2024-01-01T00:00:00.000Z", "2024-01-01T00:00:00Z");

        // DateTime with Microseconds UTC
        test_reformat_datetime_passes_cedar(
            "2025-12-11T15:26:41.123456Z",
            "2025-12-11T15:26:41.123Z",
        );
        test_reformat_datetime_passes_cedar(
            "2024-12-31T23:59:59.999999Z",
            "2024-12-31T23:59:59.999Z",
        );
        test_reformat_datetime_passes_cedar("2024-01-01T00:00:00.000000Z", "2024-01-01T00:00:00Z");

        // DateTime with Positive Timezone Offset
        test_reformat_datetime_passes_cedar("2025-12-11T15:26:41+00:00", "2025-12-11T15:26:41Z");
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+01:00",
            "2024-06-15T12:30:45+0100",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+05:30",
            "2024-06-15T12:30:45+0530",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+09:00",
            "2024-06-15T12:30:45+0900",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+12:00",
            "2024-06-15T12:30:45+1200",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+13:00",
            "2024-06-15T12:30:45+1300",
        );

        // DateTime with Negative Timezone Offset
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-05:00",
            "2024-06-15T12:30:45-0500",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-08:00",
            "2024-06-15T12:30:45-0800",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-03:30",
            "2024-06-15T12:30:45-0330",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-11:00",
            "2024-06-15T12:30:45-1100",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-23:59",
            "2024-06-15T12:30:45-2359",
        );

        // Compact Timezone Format (without colon)
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45+0100", "2024-06-15T12:30:45+0100");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45-0500", "2024-06-15T12:30:45-0500");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45+0530", "2024-06-15T12:30:45+0530");

        // DateTime with Timezone Offset and Milliseconds
        test_reformat_datetime_passes_cedar(
            "2025-12-11T15:26:41.123+01:00",
            "2025-12-11T15:26:41.123+0100",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45.500-05:00",
            "2024-06-15T12:30:45.500-0500",
        );
        test_reformat_datetime_passes_cedar(
            "2024-03-20T08:15:30.999+05:30",
            "2024-03-20T08:15:30.999+0530",
        );
        test_reformat_datetime_passes_cedar(
            "2024-12-31T23:59:59.000-08:00",
            "2024-12-31T23:59:59-0800",
        );

        // Naive DateTime (No Timezone)
        test_reformat_datetime_passes_cedar("2025-12-11T15:26:41", "2025-12-11T15:26:41Z");
        test_reformat_datetime_passes_cedar("2024-01-01T00:00:00", "2024-01-01T00:00:00Z");
        test_reformat_datetime_passes_cedar("2024-12-31T23:59:59", "2024-12-31T23:59:59Z");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45.123", "2024-06-15T12:30:45.123Z");
        test_reformat_datetime_passes_cedar("2024-03-20T08:15:30.5", "2024-03-20T08:15:30.500Z");
    }

    fn test_reformat_duration_passes_cedar(input: &str, expected: &str) {
        assert_eq!(reformat_duration(input), expected);
        let expr: RestrictedExpr = format!("duration(\"{}\")", expected)
            .parse()
            .expect(&format!(
                "reformat_duration({}) == {}, but duration(\"{}\") does not parse in Cedar",
                input, expected, expected
            ));
        let entities = Entities::new();
        let evaluator = cedar_policy_core::evaluator::Evaluator::new(
            cedar_policy_core::ast::Request::new(
                (EntityUID::from_str("P::\"\"").unwrap(), None),
                (EntityUID::from_str("Action::\"\"").unwrap(), None),
                (EntityUID::from_str("R::\"\"").unwrap(), None),
                Context::empty(),
                None::<&ValidatorSchema>,
                cedar_policy_core::extensions::Extensions::all_available(),
            )
            .unwrap(),
            &entities,
            cedar_policy_core::extensions::Extensions::all_available(),
        );
        evaluator.interpret(&expr, &HashMap::new()).expect(&format!(
            "reformat_duration({}) == {}, but duration(\"{}\") evaluates to an error in Cedar",
            input, expected, expected
        ));
    }

    #[test]
    fn test_reformat_duration() {
        // Simple Durations - Seconds
        test_reformat_duration_passes_cedar("PT0S", "0ms");
        test_reformat_duration_passes_cedar("PT1S", "1s");
        test_reformat_duration_passes_cedar("PT30S", "30s");
        test_reformat_duration_passes_cedar("PT59S", "59s");
        test_reformat_duration_passes_cedar("PT0.5S", "500ms");
        test_reformat_duration_passes_cedar("PT1.123S", "1s123ms");
        test_reformat_duration_passes_cedar("PT30.999S", "30s999ms");

        // Simple Durations - Minutes
        test_reformat_duration_passes_cedar("PT1M", "1m");
        test_reformat_duration_passes_cedar("PT30M", "30m");
        test_reformat_duration_passes_cedar("PT59M", "59m");
        test_reformat_duration_passes_cedar("PT1M30S", "1m30s");
        test_reformat_duration_passes_cedar("PT45M30S", "45m30s");
        test_reformat_duration_passes_cedar("PT59M59S", "59m59s");

        // Simple Durations - Hours
        test_reformat_duration_passes_cedar("PT1H", "1h");
        test_reformat_duration_passes_cedar("PT12H", "12h");
        test_reformat_duration_passes_cedar("PT23H", "23h");
        test_reformat_duration_passes_cedar("PT1H30M", "1h30m");
        test_reformat_duration_passes_cedar("PT2H45M30S", "2h45m30s");
        test_reformat_duration_passes_cedar("PT23H59M59S", "23h59m59s");

        // Simple Durations - Days
        test_reformat_duration_passes_cedar("P1D", "1d");
        test_reformat_duration_passes_cedar("P7D", "7d");
        test_reformat_duration_passes_cedar("P30D", "30d");
        test_reformat_duration_passes_cedar("P365D", "365d");
        test_reformat_duration_passes_cedar("P1DT12H", "1d12h");
        test_reformat_duration_passes_cedar("P1DT12H30M", "1d12h30m");
        test_reformat_duration_passes_cedar("P7DT6H30M45S", "7d6h30m45s");

        // Simple Durations - Weeks
        test_reformat_duration_passes_cedar("P1W", "7d");
        test_reformat_duration_passes_cedar("P2W", "14d");
        test_reformat_duration_passes_cedar("P4W", "28d");
        test_reformat_duration_passes_cedar("P52W", "364d");

        // Simple Durations - Months
        test_reformat_duration_passes_cedar("P1M", "30d");
        test_reformat_duration_passes_cedar("P6M", "180d");
        test_reformat_duration_passes_cedar("P11M", "330d");
        test_reformat_duration_passes_cedar("P12M", "360d");
        test_reformat_duration_passes_cedar("P1M15D", "45d");
        test_reformat_duration_passes_cedar("P6M15DT12H30M", "195d12h30m");

        // Simple Durations - Years
        test_reformat_duration_passes_cedar("P1Y", "365d");
        test_reformat_duration_passes_cedar("P2Y", "730d");
        test_reformat_duration_passes_cedar("P10Y", "3650d");
        test_reformat_duration_passes_cedar("P100Y", "36500d");
        test_reformat_duration_passes_cedar("P1Y6M", "545d");
        test_reformat_duration_passes_cedar("P1Y6M15D", "560d");
        test_reformat_duration_passes_cedar("P2Y3M4DT5H6M7S", "824d5h6m7s");

        // Complex Durations - All Components
        test_reformat_duration_passes_cedar("P1Y2M3DT4H5M6S", "428d4h5m6s");
        test_reformat_duration_passes_cedar("P3Y6M4DT12H30M5S", "1279d12h30m5s");
        test_reformat_duration_passes_cedar("P0Y0M0DT0H0M0S", "0ms");
        test_reformat_duration_passes_cedar("P1Y1M1DT1H1M1S", "396d1h1m1s");

        // Fractional Seconds
        test_reformat_duration_passes_cedar("PT0.1S", "100ms");
        test_reformat_duration_passes_cedar("PT0.01S", "10ms");
        test_reformat_duration_passes_cedar("PT0.001S", "1ms");
        test_reformat_duration_passes_cedar("PT1.5S", "1s500ms");
        test_reformat_duration_passes_cedar("PT30.123456S", "30s123ms");
        test_reformat_duration_passes_cedar("PT1M30.5S", "1m30s500ms");
        test_reformat_duration_passes_cedar("PT1H30M45.999S", "1h30m45s999ms");
        test_reformat_duration_passes_cedar("P1DT12H30M15.123S", "1d12h30m15s123ms");

        // Zero Values
        test_reformat_duration_passes_cedar("P0D", "0ms");
        test_reformat_duration_passes_cedar("PT0H", "0ms");
        test_reformat_duration_passes_cedar("PT0M", "0ms");
        test_reformat_duration_passes_cedar("PT0S", "0ms");
        test_reformat_duration_passes_cedar("P0Y", "0ms");
        test_reformat_duration_passes_cedar("P0M", "0ms");
        test_reformat_duration_passes_cedar("P0W", "0d");

        // Large Values
        test_reformat_duration_passes_cedar("PT86400S", "86400s");
        test_reformat_duration_passes_cedar("PT1440M", "1440m");
        test_reformat_duration_passes_cedar("PT24H", "24h");
        test_reformat_duration_passes_cedar("P999D", "999d");
        test_reformat_duration_passes_cedar("P999Y", "364635d");
        test_reformat_duration_passes_cedar("PT999999S", "999999s");

        // Edge Cases
        test_reformat_duration_passes_cedar("P0DT0H0M0S", "0ms");
        test_reformat_duration_passes_cedar("PT0.000001S", "0ms");
        test_reformat_duration_passes_cedar("P1Y0M0DT0H0M0S", "365d");
        test_reformat_duration_passes_cedar("P0Y0M1DT0H0M0S", "1d");
        test_reformat_duration_passes_cedar("PT0.999999999S", "999ms");
    }

    fn test_reformat_ipaddr_passes_cedar(input: &str, expected: &str) {
        assert_eq!(reformat_ipaddr(input), expected);
        let expr: RestrictedExpr = format!("ip(\"{}\")", expected).parse().expect(&format!(
            "reformat_ipaddr({}) == {}, but ip(\"{}\") does not parse in Cedar",
            input, expected, expected
        ));
        let entities = Entities::new();
        let evaluator = cedar_policy_core::evaluator::Evaluator::new(
            cedar_policy_core::ast::Request::new(
                (EntityUID::from_str("P::\"\"").unwrap(), None),
                (EntityUID::from_str("Action::\"\"").unwrap(), None),
                (EntityUID::from_str("R::\"\"").unwrap(), None),
                Context::empty(),
                None::<&ValidatorSchema>,
                cedar_policy_core::extensions::Extensions::all_available(),
            )
            .unwrap(),
            &entities,
            cedar_policy_core::extensions::Extensions::all_available(),
        );
        evaluator.interpret(&expr, &HashMap::new()).expect(&format!(
            "reformat_ipaddr({}) == {}, but ip(\"{}\") evaluates to an error in Cedar",
            input, expected, expected
        ));
    }

    #[test]
    fn test_reformat_ipaddr() {
        // IPV4 Addresses
        test_reformat_ipaddr_passes_cedar("192.168.1.1", "192.168.1.1");
        test_reformat_ipaddr_passes_cedar("10.0.0.1", "10.0.0.1");
        test_reformat_ipaddr_passes_cedar("172.16.0.5", "172.16.0.5");
        test_reformat_ipaddr_passes_cedar("8.8.8.8", "8.8.8.8");
        test_reformat_ipaddr_passes_cedar("1.1.1.1", "1.1.1.1");
        test_reformat_ipaddr_passes_cedar("127.0.0.1", "127.0.0.1");
        test_reformat_ipaddr_passes_cedar("0.0.0.0", "0.0.0.0");
        test_reformat_ipaddr_passes_cedar("255.255.255.255", "255.255.255.255");

        // IPV4 Addresses with CIDR
        test_reformat_ipaddr_passes_cedar("192.168.1.0/24", "192.168.1.0/24");
        test_reformat_ipaddr_passes_cedar("10.0.0.0/8", "10.0.0.0/8");
        test_reformat_ipaddr_passes_cedar("172.16.0.0/12", "172.16.0.0/12");
        test_reformat_ipaddr_passes_cedar("0.0.0.0/0", "0.0.0.0/0");
        test_reformat_ipaddr_passes_cedar("192.0.2.0/24", "192.0.2.0/24");
        test_reformat_ipaddr_passes_cedar("198.51.100.0/24", "198.51.100.0/24");
        test_reformat_ipaddr_passes_cedar("203.0.113.0/24", "203.0.113.0/24");

        // IPV6 Addresses
        test_reformat_ipaddr_passes_cedar(
            "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
            "2001:db8:85a3::8a2e:370:7334",
        );
        test_reformat_ipaddr_passes_cedar("2001:db8::1", "2001:db8::1");
        test_reformat_ipaddr_passes_cedar("2001:db8:abcd:0012::10", "2001:db8:abcd:12::10");
        test_reformat_ipaddr_passes_cedar("2001:db8::", "2001:db8::");
        test_reformat_ipaddr_passes_cedar("2001:db8:0:0:0:0:2:1", "2001:db8::2:1");
        test_reformat_ipaddr_passes_cedar("fe80::1", "fe80::1");
        test_reformat_ipaddr_passes_cedar("fe80::1234:abcd", "fe80::1234:abcd");
        test_reformat_ipaddr_passes_cedar("::1", "::1");
        test_reformat_ipaddr_passes_cedar("::", "::");
        test_reformat_ipaddr_passes_cedar("::ffff", "::ffff");
        test_reformat_ipaddr_passes_cedar("ff02::1", "ff02::1");
        test_reformat_ipaddr_passes_cedar("ff02::2", "ff02::2");
        test_reformat_ipaddr_passes_cedar("ff05::1:3", "ff05::1:3");
        test_reformat_ipaddr_passes_cedar("fd00::1", "fd00::1");
        test_reformat_ipaddr_passes_cedar("fc00::abcd", "fc00::abcd");

        // IPV6 Addresses with CIDR
        test_reformat_ipaddr_passes_cedar("2001:db8::/32", "2001:db8::/32");
        test_reformat_ipaddr_passes_cedar("2001:db8:abcd::/48", "2001:db8:abcd::/48");
        test_reformat_ipaddr_passes_cedar("fe80::/10", "fe80::/10");
        test_reformat_ipaddr_passes_cedar("ff00::/8", "ff00::/8");
        test_reformat_ipaddr_passes_cedar("fd00::/8", "fd00::/8");
        test_reformat_ipaddr_passes_cedar("::1/128", "::1/128");
        test_reformat_ipaddr_passes_cedar("::/0", "::/0");
        test_reformat_ipaddr_passes_cedar("2001:db8:85a3::/64", "2001:db8:85a3::/64");

        // IPV6 addresses with embedded IPV4 address
        test_reformat_ipaddr_passes_cedar("::ffff:192.168.1.1", "192.168.1.1");
        test_reformat_ipaddr_passes_cedar("::ffff:10.0.0.1", "10.0.0.1");
        test_reformat_ipaddr_passes_cedar("::ffff:172.16.0.5", "172.16.0.5");
        test_reformat_ipaddr_passes_cedar("::ffff:8.8.8.8", "8.8.8.8");
        test_reformat_ipaddr_passes_cedar("::192.168.1.1", "::c0a8:101");
        test_reformat_ipaddr_passes_cedar("::10.0.0.1", "::a00:1");
        test_reformat_ipaddr_passes_cedar("::172.16.0.5", "::ac10:5");
        test_reformat_ipaddr_passes_cedar("::8.8.8.8", "::808:808");

        // More IPV6 Addresses
        test_reformat_ipaddr_passes_cedar("fe80::", "fe80::");
        test_reformat_ipaddr_passes_cedar("fe80::20c:29ff:fe9d:1a2b", "fe80::20c:29ff:fe9d:1a2b");
        test_reformat_ipaddr_passes_cedar("fe80::a1b2:c3d4:e5f6", "fe80::a1b2:c3d4:e5f6");
        test_reformat_ipaddr_passes_cedar("fd12:3456:789a::1", "fd12:3456:789a::1");
        test_reformat_ipaddr_passes_cedar("fd00:aaaa:bbbb:cccc::1", "fd00:aaaa:bbbb:cccc::1");
        test_reformat_ipaddr_passes_cedar("fc00:1234::abcd", "fc00:1234::abcd");
        test_reformat_ipaddr_passes_cedar("fdff:ffff:ffff:ffff::", "fdff:ffff:ffff:ffff::");
    }
}
