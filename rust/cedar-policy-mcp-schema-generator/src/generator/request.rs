/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

use std::collections::{HashMap, HashSet};
use std::sync::Arc;

use cedar_policy_core::ast::{
    Context, Eid, Entity, EntityType, EntityUID, InternalName, Name, Request, RestrictedExpr,
};
use cedar_policy_core::entities::Entities;
use cedar_policy_core::validator::ValidatorSchema;

use chrono::{DateTime, NaiveDate, NaiveDateTime, TimeZone, Utc};

use super::identifiers;
use crate::{RequestGeneratorError, SchemaGeneratorConfig};

use mcp_tools_sdk::data::{Input, Output, TypedValue};
use mcp_tools_sdk::description::{PropertyTypeDef, ServerDescription};
use smol_str::{SmolStr, ToSmolStr};
use uuid::Uuid;

#[derive(Clone, Debug)]
/// A `RequestGenerator` is a structure produced by a `SchemaGenerator` which allows
/// a user to generator Cedar Requests that are valid for the Schema generated by the
/// `SchemaGenerator`.
pub struct RequestGenerator {
    config: SchemaGeneratorConfig,
    tools: ServerDescription,
    root_namespace: Option<Name>,
    schema: ValidatorSchema,
}

#[derive(Clone, Debug)]
struct TypeDefsInfo {
    info: HashMap<SmolStr, Option<Arc<Name>>>,
}

impl TypeDefsInfo {
    fn new() -> Self {
        Self {
            info: HashMap::new(),
        }
    }

    fn extend<'a>(
        &mut self,
        ty_defs: impl IntoIterator<Item = &'a PropertyTypeDef>,
        namespace: Option<Name>,
    ) {
        let namespace = namespace.map(Arc::new);
        self.info.extend(
            ty_defs
                .into_iter()
                .map(|ty_def| (ty_def.name().to_smolstr(), namespace.clone())),
        )
    }

    fn get(&self, type_name: &SmolStr) -> Option<&Name> {
        self.info.get(type_name).and_then(|ns| ns.as_deref())
    }
}

impl RequestGenerator {
    pub(crate) fn new(
        config: SchemaGeneratorConfig,
        tools: ServerDescription,
        root_namespace: Option<Name>,
        schema: ValidatorSchema,
    ) -> Self {
        Self {
            config,
            tools,
            root_namespace,
            schema,
        }
    }

    /// Generate an authorization request & entities necessary to call the Cedar authorization engine.
    /// A user of this function is expected to provide
    /// (1) the principal and resource of the request
    /// (2) any common context elements
    /// (3) any entity information for the principal, resource, and common context
    /// (4) the MCP tool input request, and (5) optionally the MCP tool output response
    ///
    /// The function will then return a Cedar Request and entities necessary to determine if the principal is
    /// authorized to use (or receive the oputout of) the requested tool.
    pub fn generate_request(
        &self,
        principal: EntityUID,
        resource: EntityUID,
        context: impl IntoIterator<Item = (SmolStr, RestrictedExpr)>,
        mut entities: Entities,
        input: &Input,
        output: Option<&Output>,
    ) -> Result<(Request, Entities), RequestGeneratorError> {
        let input = self.tools.validate_input(input)?;
        // PANIC SAFETY: `self.tools` must contain a tool named `input.name()` and `input` validates against `tool`
        #[allow(
            clippy::unwrap_used,
            reason = "Validation ensures there is a tool in with the same name that the input validates against"
        )]
        let tool = self
            .tools
            .tool_descriptions()
            .find(|t| t.name() == input.name())
            .unwrap();

        let output = output
            .map(|output| self.tools.validate_output(tool.name(), output))
            .transpose()?;

        let mut type_defs = TypeDefsInfo::new();
        type_defs.extend(self.tools.type_definitions(), self.root_namespace.clone());

        let tool_ns: Name = tool.name().parse()?;
        let tool_ns = tool_ns.qualify_with_name(self.root_namespace.as_ref());

        // Extend with tool specific type definitions
        type_defs.extend(tool.type_definitions(), Some(tool_ns.clone()));

        // Combine server / tool / input specific type defs
        let input_ns = identifiers::INPUT_NAME.qualify_with_name(Some(&tool_ns));
        let mut inputs_type_defs = type_defs.clone();
        inputs_type_defs.extend(tool.inputs().type_definitions(), Some(input_ns.clone()));

        let (inputs, new_entities) =
            self.values_to_cedar(input.get_args(), &inputs_type_defs, Some(&input_ns))?;
        entities = entities.add_entities(
            new_entities.into_iter().map(Arc::from),
            None::<&cedar_policy_core::validator::CoreSchema<'_>>,
            cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
            cedar_policy_core::extensions::Extensions::all_available(),
        )?;

        let context = match &output {
            Some(output) if self.config.include_outputs => {
                // Combine server / tool / output specific type defs
                let output_ns = identifiers::OUTPUT_NAME.qualify_with_name(Some(&tool_ns));
                let mut outputs_type_defs = type_defs.clone();
                outputs_type_defs
                    .extend(tool.outputs().type_definitions(), Some(output_ns.clone()));

                let (outputs, new_entities) = self.values_to_cedar(
                    output.get_results(),
                    &outputs_type_defs,
                    Some(&output_ns),
                )?;
                entities = entities.add_entities(
                    new_entities.into_iter().map(Arc::from),
                    None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                    cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                    cedar_policy_core::extensions::Extensions::all_available(),
                )?;
                context.into_iter().chain(vec![
                    ("input".to_smolstr(), inputs),
                    ("output".to_smolstr(), outputs),
                ])
            }
            _ => context
                .into_iter()
                .chain(vec![("input".to_smolstr(), inputs)]),
        };
        let context = Context::from_pairs(
            context,
            cedar_policy_core::extensions::Extensions::all_available(),
        )?;

        let action_name = Eid::new(tool.name());
        let action = EntityUID::from_components(
            identifiers::ACTION.qualify_with(self.root_namespace.as_ref()),
            action_name,
            None,
        );
        // Create final request and pass schema to force validation of request
        // By validating we ensure tht the provided principal, resource, and common contexts
        // provided by the user actually match the generated schema
        let request = Request::new(
            (principal, None),
            (action, None),
            (resource, None),
            context,
            Some(&self.schema),
            cedar_policy_core::extensions::Extensions::all_available(),
        )?;

        Ok((request, entities))
    }

    fn values_to_cedar<'a>(
        &self,
        vals: impl Iterator<Item = (&'a str, &'a TypedValue)>,
        type_defs: &TypeDefsInfo,
        namespace: Option<&Name>,
    ) -> Result<(RestrictedExpr, Entities), RequestGeneratorError> {
        let mut entities = Entities::new();
        let mut exprs = HashMap::new();
        for (name, arg) in vals {
            let (expr, new_entities) = self.val_to_cedar(arg, type_defs, namespace, name)?;
            entities = entities.add_entities(
                new_entities.into_iter().map(Arc::from),
                None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                cedar_policy_core::extensions::Extensions::all_available(),
            )?;
            exprs.insert(name.to_smolstr(), expr);
        }
        Ok((RestrictedExpr::record(exprs)?, entities))
    }

    fn val_to_cedar(
        &self,
        val: &TypedValue,
        type_defs: &TypeDefsInfo,
        namespace: Option<&Name>,
        ty_name: &str,
    ) -> Result<(RestrictedExpr, Entities), RequestGeneratorError> {
        match val {
            TypedValue::Null => {
                let ty = EntityType::from(Name::from(identifiers::NULL_TYPE.clone()));
                let ty = ty.qualify_with(self.root_namespace.as_ref());
                let eid = Eid::new("null");
                let euid = EntityUID::from_components(ty, eid, None);
                Ok((RestrictedExpr::val(euid), Entities::new()))
            }
            TypedValue::Bool(b) => Ok((RestrictedExpr::val(*b), Entities::new())),
            TypedValue::Integer(i) => Ok((RestrictedExpr::val(*i), Entities::new())),
            TypedValue::Float(f) => {
                if self.config.numbers_as_decimal {
                    let val = RestrictedExpr::val(format!("{:.4}", f));
                    Ok((
                        RestrictedExpr::call_extension_fn(
                            identifiers::DECIMAL_CTOR.clone(),
                            vec![val],
                        ),
                        Entities::new(),
                    ))
                } else {
                    let ty = EntityType::from(Name::from(identifiers::FLOAT_TYPE.clone()));
                    let ty = ty.qualify_with(self.root_namespace.as_ref());
                    let eid = Eid::new(format!("{}", f));
                    let euid = EntityUID::from_components(ty, eid, None);
                    Ok((RestrictedExpr::val(euid), Entities::new()))
                }
            }
            TypedValue::Number(n) => {
                if self.config.numbers_as_decimal {
                    let val = match (n.to_f64(), n.to_i64()) {
                        (_, Some(i)) => format!("{}.0", i),
                        (Some(f), _) => format!("{:.4}", f),
                        _ => {
                            return Err(RequestGeneratorError::MalformedDecimalNumber(
                                n.as_str().into(),
                            ));
                        }
                    };
                    let val = RestrictedExpr::val(val);
                    Ok((
                        RestrictedExpr::call_extension_fn(
                            identifiers::DECIMAL_CTOR.clone(),
                            vec![val],
                        ),
                        Entities::new(),
                    ))
                } else {
                    let ty = EntityType::from(Name::from(identifiers::NUMBER_TYPE.clone()));
                    let ty = ty.qualify_with(self.root_namespace.as_ref());
                    let eid = Eid::new(n.as_str());
                    let euid = EntityUID::from_components(ty, eid, None);
                    Ok((RestrictedExpr::val(euid), Entities::new()))
                }
            }
            TypedValue::String(s) => Ok((RestrictedExpr::val(s.as_str()), Entities::new())),
            TypedValue::Decimal(s) => {
                let val = RestrictedExpr::val(s.as_str());
                Ok((
                    RestrictedExpr::call_extension_fn(identifiers::DECIMAL_CTOR.clone(), vec![val]),
                    Entities::new(),
                ))
            }
            TypedValue::Datetime(s) => {
                let val = RestrictedExpr::val(reformat_datestr(s.as_str()));
                Ok((
                    RestrictedExpr::call_extension_fn(
                        identifiers::DATETIME_CTOR.clone(),
                        vec![val],
                    ),
                    Entities::new(),
                ))
            }
            TypedValue::Duration(s) => {
                let val = RestrictedExpr::val(reformat_duration(s.as_str()));
                Ok((
                    RestrictedExpr::call_extension_fn(
                        identifiers::DURATION_CTOR.clone(),
                        vec![val],
                    ),
                    Entities::new(),
                ))
            }
            TypedValue::IpAddr(s) => {
                let val = RestrictedExpr::val(reformat_ipaddr(s.as_str()));
                Ok((
                    RestrictedExpr::call_extension_fn(identifiers::IPADDR_CTOR.clone(), vec![val]),
                    Entities::new(),
                ))
            }
            TypedValue::Unknown(_) => {
                let ty = EntityType::from(Name::from(identifiers::UNKNOWN_TYPE.clone()));
                let ty = ty.qualify_with(self.root_namespace.as_ref());
                // Generate a unique EID for all Unknown values
                // with the implication being that any unkonwn value is different from any other
                // unknown value even if they were the same JSON value.
                let eid = Eid::new(Uuid::new_v4().to_smolstr());
                let euid = EntityUID::from_components(ty, eid, None);
                Ok((RestrictedExpr::val(euid), Entities::new()))
            }
            TypedValue::Enum(s) => {
                let ty: EntityType = ty_name.parse()?;
                let ty = ty.qualify_with(namespace);
                let eid = Eid::new(s.as_str());
                let euid = EntityUID::from_components(ty, eid, None);
                let euid = if self.config.flatten_namespaces {
                    flatten_name(euid)
                } else {
                    euid
                };
                Ok((RestrictedExpr::val(euid), Entities::new()))
            }
            TypedValue::Array(vals) => {
                let mut exprs = Vec::new();
                let mut entities = Entities::new();
                for val in vals {
                    let (expr, new_entities) =
                        self.val_to_cedar(val, type_defs, namespace, ty_name)?;
                    entities = entities.add_entities(
                        new_entities.into_iter().map(Arc::from),
                        None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                        cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                        cedar_policy_core::extensions::Extensions::all_available(),
                    )?;
                    exprs.push(expr);
                }
                Ok((RestrictedExpr::set(exprs), entities))
            }
            TypedValue::Tuple(vals) => {
                let mut pairs = HashMap::new();
                let mut entities = Entities::new();
                for (i, val) in vals.iter().enumerate() {
                    let sub_ty_name = format!("Proj{i}");
                    let name = format!("proj{i}").to_smolstr();
                    let sub_namespace: Name = ty_name.parse()?;
                    let sub_namespace = sub_namespace.qualify_with_name(namespace);
                    let (expr, new_entities) =
                        self.val_to_cedar(val, type_defs, Some(&sub_namespace), &sub_ty_name)?;
                    entities = entities.add_entities(
                        new_entities.into_iter().map(Arc::from),
                        None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                        cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                        cedar_policy_core::extensions::Extensions::all_available(),
                    )?;
                    pairs.insert(name, expr);
                }
                Ok((RestrictedExpr::record(pairs)?, entities))
            }
            TypedValue::Union { index, value } => {
                let sub_ty_name = format!("TypeChoice{}", index);
                let name = format!("typeChoice{}", index).to_smolstr();
                let sub_namespace: Name = ty_name.parse()?;
                let sub_namespace = sub_namespace.qualify_with_name(namespace);
                let (expr, entities) =
                    self.val_to_cedar(value, type_defs, Some(&sub_namespace), &sub_ty_name)?;
                Ok((RestrictedExpr::record([(name, expr)])?, entities))
            }
            TypedValue::Object {
                properties,
                additional_properties,
            } => {
                let sub_namespace: Name = ty_name.parse()?;
                let sub_namespace = sub_namespace.qualify_with_name(namespace);

                let mut entities = Entities::new();
                let into_pairs = |props: &HashMap<SmolStr, TypedValue>,
                                  entities: &mut Entities|
                 -> Result<
                    HashMap<SmolStr, RestrictedExpr>,
                    RequestGeneratorError,
                > {
                    let mut pairs = HashMap::new();
                    for (name, val) in props.iter() {
                        let (expr, new_entities) =
                            self.val_to_cedar(val, type_defs, Some(&sub_namespace), name.as_ref())?;
                        let old_entities = std::mem::replace(entities, Entities::new());
                        *entities = old_entities.add_entities(
                            new_entities.into_iter().map(Arc::from),
                            None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                            cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                            cedar_policy_core::extensions::Extensions::all_available(),
                        )?;
                        pairs.insert(name.clone(), expr);
                    }
                    Ok(pairs)
                };

                let pairs = into_pairs(properties, &mut entities)?;
                let tags = into_pairs(additional_properties, &mut entities)?;

                if tags.is_empty() && self.config.objects_as_records {
                    Ok((RestrictedExpr::record(pairs.into_iter())?, entities))
                } else {
                    let entity_ty: EntityType = ty_name.parse()?;
                    let entity_ty = entity_ty.qualify_with(namespace);
                    // Generate a unique EID for each object's entity representation
                    // This means that all entities are different from all other entities
                    // even if the entities are structurally equivalent.
                    // Perhaps we could generate EIDs in a way that result in equal EIDs for
                    // structurally equivalent entities.
                    let eid = Eid::new(Uuid::new_v4().to_smolstr());
                    let euid = EntityUID::from_components(entity_ty, eid, None);
                    let euid = if self.config.flatten_namespaces {
                        flatten_name(euid)
                    } else {
                        euid
                    };
                    let entity = Entity::new(
                        euid.clone(),
                        pairs,
                        HashSet::new(),
                        HashSet::new(),
                        tags,
                        cedar_policy_core::extensions::Extensions::all_available(),
                    )?;
                    entities = entities.add_entities(
                        [Arc::from(entity)],
                        None::<&cedar_policy_core::validator::CoreSchema<'_>>,
                        cedar_policy_core::entities::TCComputation::AssumeAlreadyComputed,
                        cedar_policy_core::extensions::Extensions::all_available(),
                    )?;
                    Ok((RestrictedExpr::val(euid), entities))
                }
            }
            TypedValue::Ref { name, val } => {
                self.val_to_cedar(val, type_defs, type_defs.get(name), name.as_str())
            }
        }
    }
}

// PANIC SAFETY: The input `str` should have been validated as a date-time str, and should parse
#[allow(clippy::unreachable)]
/// This function converts from JSON date or date-time formatted strings to Cedar datetime strings.
/// This conversion uses chrono library to parse and reformat the strings appropriately.
///
/// Note: this function loses sub-millisecond precision
fn reformat_datestr(str: &str) -> String {
    // Try parsing as date only (YYYY-MM-DD)
    if let Ok(date) = NaiveDate::parse_from_str(str, "%Y-%m-%d") {
        return date.format("%Y-%m-%d").to_string();
    }

    // Try parsing as RFC3339 (with timezone)
    if let Ok(dt) = DateTime::parse_from_rfc3339(str) {
        let dt_utc = dt.with_timezone(&Utc);

        // Check if it has subsecond precision
        if dt_utc.timestamp_subsec_millis() > 0 {
            // With milliseconds
            if dt.offset().local_minus_utc() == 0 {
                // UTC with milliseconds: YYYY-MM-DDTHH:MM:SS.sssZ
                return dt_utc.format("%Y-%m-%dT%H:%M:%S%.3fZ").to_string();
            } else {
                // With timezone offset and milliseconds: YYYY-MM-DDTHH:MM:SS.sss+0100
                return dt.format("%Y-%m-%dT%H:%M:%S%.3f%z").to_string();
            }
        } else {
            // Without milliseconds
            if dt.offset().local_minus_utc() == 0 {
                // UTC: YYYY-MM-DDTHH:MM:SSZ
                return dt_utc.format("%Y-%m-%dT%H:%M:%SZ").to_string();
            } else {
                // With timezone offset: YYYY-MM-DDTHH:MM:SS+0100
                return dt.format("%Y-%m-%dT%H:%M:%S%z").to_string();
            }
        }
    }

    // Try parsing with basic timezone format (no fractional seconds)
    if let Ok(dt) = DateTime::parse_from_str(str, "%Y-%m-%dT%H:%M:%S%z") {
        let dt_utc = dt.with_timezone(&Utc);

        if dt.offset().local_minus_utc() == 0 {
            return dt_utc.format("%Y-%m-%dT%H:%M:%SZ").to_string();
        } else {
            return dt.format("%Y-%m-%dT%H:%M:%S%z").to_string();
        }
    }

    // Try parsing with basic timezone format WITH fractional seconds
    if let Ok(dt) = DateTime::parse_from_str(str, "%Y-%m-%dT%H:%M:%S%.f%z") {
        let dt_utc = dt.with_timezone(&Utc);

        if dt_utc.timestamp_subsec_millis() > 0 {
            if dt.offset().local_minus_utc() == 0 {
                return dt_utc.format("%Y-%m-%dT%H:%M:%S%.3fZ").to_string();
            } else {
                return dt.format("%Y-%m-%dT%H:%M:%S%.3f%z").to_string();
            }
        } else if dt.offset().local_minus_utc() == 0 {
            return dt_utc.format("%Y-%m-%dT%H:%M:%SZ").to_string();
        } else {
            return dt.format("%Y-%m-%dT%H:%M:%S%z").to_string();
        }
    }

    // Try parsing as naive datetime (no timezone)
    if let Ok(ndt) = NaiveDateTime::parse_from_str(str, "%Y-%m-%dT%H:%M:%S%.f") {
        // Convert to UTC (assuming input is UTC)
        let dt_utc = Utc.from_utc_datetime(&ndt);

        // Check if it has subsecond precision
        if dt_utc.timestamp_subsec_millis() > 0 {
            // UTC with milliseconds: YYYY-MM-DDTHH:MM:SS.sssZ
            return dt_utc.format("%Y-%m-%dT%H:%M:%S%.3fZ").to_string();
        } else {
            // UTC without milliseconds: YYYY-MM-DDTHH:MM:SSZ
            return dt_utc.format("%Y-%m-%dT%H:%M:%SZ").to_string();
        }
    }

    unreachable!("Validated DatetimeStrings should be parsable")
}

/// This function converts from the iso8601 standard for Duration (JSON duration formatted strings) into
/// cedar formatted durations. Unfortunately, iso8601 uses calendar based durations, and Cedar uses fixed
/// time durations. This means that the best we can do for converting iso8601 durations that contain
/// months or year components is to approximate (e.g., 1 year = 365 days and 1 month = 30 days).
fn reformat_duration(str: &str) -> String {
    // PANIC SAFETY: validation ensures that the input `str` will parse as an `iso8601::Duration`
    #[allow(clippy::unwrap_used)]
    let duration = iso8601::duration(str).unwrap();

    match duration {
        iso8601::Duration::YMDHMS {
            year,
            month,
            day,
            hour,
            minute,
            second,
            millisecond,
        } => {
            // APPROXIMATE year & month into number of days
            let n_days = year * 365 + month * 30 + day;
            let mut ret = "".to_string();
            if n_days != 0 {
                ret = format!("{}{}d", ret, n_days)
            }
            if hour != 0 {
                ret = format!("{}{}h", ret, hour)
            }
            if minute != 0 {
                ret = format!("{}{}m", ret, minute)
            }
            if second != 0 {
                ret = format!("{}{}s", ret, second)
            }
            if millisecond != 0 || ret.is_empty() {
                ret = format!("{}{}ms", ret, millisecond)
            }
            ret
        }
        iso8601::Duration::Weeks(weeks) => {
            let n_days = 7 * weeks;
            format!("{}d", n_days)
        }
    }
}

/// This function converts from JSON compliant ipv4 and ipv6 formatted strings (which can be parsed by `std::net::IpAddr`)
/// to Cedar compliant IpAddr strings (which requires a stricter formatting, e.g., no leading 0s).
/// This is accomplished by passing through Rust's IpAddr type which allows lax formatting during deserialization and stricter formatting
/// during serialization to string.
fn reformat_ipaddr(str: &str) -> String {
    // PANIC SAFETY: validation ensures that the input `str` will parse as an `IpAddr` or `IpNet`
    #[allow(clippy::unwrap_used)]
    str.parse::<std::net::IpAddr>()
        .map(|ip| {
            // Convert IPv4-mapped IPv6 to IPv4
            match ip {
                std::net::IpAddr::V6(v6) => {
                    if let Some(ipv4) = v6.to_ipv4_mapped() {
                        std::net::IpAddr::V4(ipv4).to_string()
                    } else {
                        ip.to_string()
                    }
                }
                std::net::IpAddr::V4(_) => ip.to_string(),
            }
        })
        .unwrap_or_else(|_| {
            str.parse::<ipnet::IpNet>()
                .map(|ipnet| {
                    // Handle IpNet case - convert if it's IPv4-mapped
                    match ipnet.addr() {
                        std::net::IpAddr::V6(v6) => {
                            if let Some(ipv4) = v6.to_ipv4_mapped() {
                                // Reconstruct with IPv4 and original prefix length
                                format!("{}/{}", ipv4, ipnet.prefix_len())
                            } else {
                                ipnet.to_string()
                            }
                        }
                        std::net::IpAddr::V4(_) => ipnet.to_string(),
                    }
                })
                .unwrap()
        })
}

// PANIC SAFETY: the input EntityUID is valid. Transforming to flatten the entity type name should be safe
#[allow(clippy::unwrap_used)]
/// Flatten an EntityUID's typename to be consistent with the transformation used in Schema generator when flatten_namespaces
/// configuration option is set to true. That transformation transforms a name `TopLevelNamespace::Other::Name::Spaces::BaseName`
/// into the name `TopLevelNameSpace::Other_Name_Spaces_BaseName`.
fn flatten_name(euid: EntityUID) -> EntityUID {
    let (entity_type, eid) = euid.components();
    let entity_type = entity_type.name().qualify_with(None);
    let mut parts = entity_type
        .namespace_components()
        .chain(std::iter::once(entity_type.basename()))
        .cloned();
    let flattened_namespace = parts
        .next()
        .map(InternalName::from)
        .map(Name::try_from)
        .transpose()
        .unwrap();
    let flattened_basename = parts.map(|id| id.to_string()).collect::<Vec<_>>().join("_");
    let entity_type: EntityType = flattened_basename.parse().unwrap();
    let entity_type = entity_type.qualify_with(flattened_namespace.as_ref());
    EntityUID::from_components(entity_type, eid, None)
}

#[cfg(test)]
mod test {
    use cedar_policy_core::ast::{Literal, PartialValue, Value, ValueKind};
    use cedar_policy_core::entities::Dereference;
    use cool_asserts::assert_matches;
    use std::str::FromStr;

    use mcp_tools_sdk::description::ToolDescription;

    use crate::SchemaGenerator;

    use super::*;

    fn test_reformat_datetime_passes_cedar(input: &str, expected: &str) {
        assert_eq!(reformat_datestr(input), expected);
        let expr: RestrictedExpr = format!("datetime(\"{}\")", expected)
            .parse()
            .expect(&format!(
                "reformat_datestr({}) == {}, but datetime(\"{}\") does not parse in Cedar",
                input, expected, expected
            ));
        let entities = Entities::new();
        let evaluator = cedar_policy_core::evaluator::Evaluator::new(
            cedar_policy_core::ast::Request::new(
                (EntityUID::from_str("P::\"\"").unwrap(), None),
                (EntityUID::from_str("Action::\"\"").unwrap(), None),
                (EntityUID::from_str("R::\"\"").unwrap(), None),
                Context::empty(),
                None::<&ValidatorSchema>,
                cedar_policy_core::extensions::Extensions::all_available(),
            )
            .unwrap(),
            &entities,
            cedar_policy_core::extensions::Extensions::all_available(),
        );
        evaluator.interpret(&expr, &HashMap::new()).expect(&format!(
            "reformat_datestr({}) == {}, but datetime(\"{}\") evaluates to an error in Cedar",
            input, expected, expected
        ));
    }

    #[test]
    fn test_reformat_datetime_str() {
        // Date Only (YYYY-MM-DD)
        test_reformat_datetime_passes_cedar("2025-12-11", "2025-12-11");
        test_reformat_datetime_passes_cedar("2024-01-01", "2024-01-01");
        test_reformat_datetime_passes_cedar("2024-12-31", "2024-12-31");
        test_reformat_datetime_passes_cedar("2024-02-29", "2024-02-29");
        test_reformat_datetime_passes_cedar("2023-02-28", "2023-02-28");
        test_reformat_datetime_passes_cedar("1970-01-01", "1970-01-01");
        test_reformat_datetime_passes_cedar("2099-12-31", "2099-12-31");

        // DateTime UTC (RFC3339,
        test_reformat_datetime_passes_cedar("2025-12-11T15:26:41Z", "2025-12-11T15:26:41Z");
        test_reformat_datetime_passes_cedar("2024-01-01T00:00:00Z", "2024-01-01T00:00:00Z");
        test_reformat_datetime_passes_cedar("2024-12-31T23:59:59Z", "2024-12-31T23:59:59Z");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45Z", "2024-06-15T12:30:45Z");
        test_reformat_datetime_passes_cedar("1970-01-01T00:00:00Z", "1970-01-01T00:00:00Z");

        // DateTime with Milliseconds UTC
        test_reformat_datetime_passes_cedar("2025-12-11T15:26:41.123Z", "2025-12-11T15:26:41.123Z");
        test_reformat_datetime_passes_cedar("2024-12-31T23:59:59.999Z", "2024-12-31T23:59:59.999Z");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45.500Z", "2024-06-15T12:30:45.500Z");
        test_reformat_datetime_passes_cedar("2024-03-20T08:15:30.001Z", "2024-03-20T08:15:30.001Z");
        test_reformat_datetime_passes_cedar("2024-01-01T00:00:00.000Z", "2024-01-01T00:00:00Z");

        // DateTime with Microseconds UTC
        test_reformat_datetime_passes_cedar(
            "2025-12-11T15:26:41.123456Z",
            "2025-12-11T15:26:41.123Z",
        );
        test_reformat_datetime_passes_cedar(
            "2024-12-31T23:59:59.999999Z",
            "2024-12-31T23:59:59.999Z",
        );
        test_reformat_datetime_passes_cedar("2024-01-01T00:00:00.000000Z", "2024-01-01T00:00:00Z");

        // DateTime with Positive Timezone Offset
        test_reformat_datetime_passes_cedar("2025-12-11T15:26:41+00:00", "2025-12-11T15:26:41Z");
        test_reformat_datetime_passes_cedar("2025-12-11T15:26:41-00:00", "2025-12-11T15:26:41Z");
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+01:00",
            "2024-06-15T12:30:45+0100",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+05:30",
            "2024-06-15T12:30:45+0530",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+09:00",
            "2024-06-15T12:30:45+0900",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+12:00",
            "2024-06-15T12:30:45+1200",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45+13:00",
            "2024-06-15T12:30:45+1300",
        );

        // DateTime with Negative Timezone Offset
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-05:00",
            "2024-06-15T12:30:45-0500",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-08:00",
            "2024-06-15T12:30:45-0800",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-03:30",
            "2024-06-15T12:30:45-0330",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-11:00",
            "2024-06-15T12:30:45-1100",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45-23:59",
            "2024-06-15T12:30:45-2359",
        );

        // Compact Timezone Format (without colon)
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45+0000", "2024-06-15T12:30:45Z");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45.0+0000", "2024-06-15T12:30:45Z");
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45.01+0000",
            "2024-06-15T12:30:45.010Z",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45.0+0100",
            "2024-06-15T12:30:45+0100",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45.01+0100",
            "2024-06-15T12:30:45.010+0100",
        );
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45+0100", "2024-06-15T12:30:45+0100");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45-0500", "2024-06-15T12:30:45-0500");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45+0530", "2024-06-15T12:30:45+0530");

        // DateTime with Timezone Offset and Milliseconds
        test_reformat_datetime_passes_cedar(
            "2025-12-11T15:26:41.123+01:00",
            "2025-12-11T15:26:41.123+0100",
        );
        test_reformat_datetime_passes_cedar(
            "2024-06-15T12:30:45.500-05:00",
            "2024-06-15T12:30:45.500-0500",
        );
        test_reformat_datetime_passes_cedar(
            "2024-03-20T08:15:30.999+05:30",
            "2024-03-20T08:15:30.999+0530",
        );
        test_reformat_datetime_passes_cedar(
            "2024-12-31T23:59:59.000-08:00",
            "2024-12-31T23:59:59-0800",
        );

        // Naive DateTime (No Timezone)
        test_reformat_datetime_passes_cedar("2025-12-11T15:26:41", "2025-12-11T15:26:41Z");
        test_reformat_datetime_passes_cedar("2024-01-01T00:00:00", "2024-01-01T00:00:00Z");
        test_reformat_datetime_passes_cedar("2024-12-31T23:59:59", "2024-12-31T23:59:59Z");
        test_reformat_datetime_passes_cedar("2024-06-15T12:30:45.123", "2024-06-15T12:30:45.123Z");
        test_reformat_datetime_passes_cedar("2024-03-20T08:15:30.5", "2024-03-20T08:15:30.500Z");
    }

    fn test_reformat_duration_passes_cedar(input: &str, expected: &str) {
        assert_eq!(reformat_duration(input), expected);
        let expr: RestrictedExpr = format!("duration(\"{}\")", expected)
            .parse()
            .expect(&format!(
                "reformat_duration({}) == {}, but duration(\"{}\") does not parse in Cedar",
                input, expected, expected
            ));
        let entities = Entities::new();
        let evaluator = cedar_policy_core::evaluator::Evaluator::new(
            cedar_policy_core::ast::Request::new(
                (EntityUID::from_str("P::\"\"").unwrap(), None),
                (EntityUID::from_str("Action::\"\"").unwrap(), None),
                (EntityUID::from_str("R::\"\"").unwrap(), None),
                Context::empty(),
                None::<&ValidatorSchema>,
                cedar_policy_core::extensions::Extensions::all_available(),
            )
            .unwrap(),
            &entities,
            cedar_policy_core::extensions::Extensions::all_available(),
        );
        evaluator.interpret(&expr, &HashMap::new()).expect(&format!(
            "reformat_duration({}) == {}, but duration(\"{}\") evaluates to an error in Cedar",
            input, expected, expected
        ));
    }

    #[test]
    fn test_reformat_duration() {
        // Simple Durations - Seconds
        test_reformat_duration_passes_cedar("PT0S", "0ms");
        test_reformat_duration_passes_cedar("PT1S", "1s");
        test_reformat_duration_passes_cedar("PT30S", "30s");
        test_reformat_duration_passes_cedar("PT59S", "59s");
        test_reformat_duration_passes_cedar("PT0.5S", "500ms");
        test_reformat_duration_passes_cedar("PT1.123S", "1s123ms");
        test_reformat_duration_passes_cedar("PT30.999S", "30s999ms");

        // Simple Durations - Minutes
        test_reformat_duration_passes_cedar("PT1M", "1m");
        test_reformat_duration_passes_cedar("PT30M", "30m");
        test_reformat_duration_passes_cedar("PT59M", "59m");
        test_reformat_duration_passes_cedar("PT1M30S", "1m30s");
        test_reformat_duration_passes_cedar("PT45M30S", "45m30s");
        test_reformat_duration_passes_cedar("PT59M59S", "59m59s");

        // Simple Durations - Hours
        test_reformat_duration_passes_cedar("PT1H", "1h");
        test_reformat_duration_passes_cedar("PT12H", "12h");
        test_reformat_duration_passes_cedar("PT23H", "23h");
        test_reformat_duration_passes_cedar("PT1H30M", "1h30m");
        test_reformat_duration_passes_cedar("PT2H45M30S", "2h45m30s");
        test_reformat_duration_passes_cedar("PT23H59M59S", "23h59m59s");

        // Simple Durations - Days
        test_reformat_duration_passes_cedar("P1D", "1d");
        test_reformat_duration_passes_cedar("P7D", "7d");
        test_reformat_duration_passes_cedar("P30D", "30d");
        test_reformat_duration_passes_cedar("P365D", "365d");
        test_reformat_duration_passes_cedar("P1DT12H", "1d12h");
        test_reformat_duration_passes_cedar("P1DT12H30M", "1d12h30m");
        test_reformat_duration_passes_cedar("P7DT6H30M45S", "7d6h30m45s");

        // Simple Durations - Weeks
        test_reformat_duration_passes_cedar("P1W", "7d");
        test_reformat_duration_passes_cedar("P2W", "14d");
        test_reformat_duration_passes_cedar("P4W", "28d");
        test_reformat_duration_passes_cedar("P52W", "364d");

        // Simple Durations - Months
        test_reformat_duration_passes_cedar("P1M", "30d");
        test_reformat_duration_passes_cedar("P6M", "180d");
        test_reformat_duration_passes_cedar("P11M", "330d");
        test_reformat_duration_passes_cedar("P12M", "360d");
        test_reformat_duration_passes_cedar("P1M15D", "45d");
        test_reformat_duration_passes_cedar("P6M15DT12H30M", "195d12h30m");

        // Simple Durations - Years
        test_reformat_duration_passes_cedar("P1Y", "365d");
        test_reformat_duration_passes_cedar("P2Y", "730d");
        test_reformat_duration_passes_cedar("P10Y", "3650d");
        test_reformat_duration_passes_cedar("P100Y", "36500d");
        test_reformat_duration_passes_cedar("P1Y6M", "545d");
        test_reformat_duration_passes_cedar("P1Y6M15D", "560d");
        test_reformat_duration_passes_cedar("P2Y3M4DT5H6M7S", "824d5h6m7s");

        // Complex Durations - All Components
        test_reformat_duration_passes_cedar("P1Y2M3DT4H5M6S", "428d4h5m6s");
        test_reformat_duration_passes_cedar("P3Y6M4DT12H30M5S", "1279d12h30m5s");
        test_reformat_duration_passes_cedar("P0Y0M0DT0H0M0S", "0ms");
        test_reformat_duration_passes_cedar("P1Y1M1DT1H1M1S", "396d1h1m1s");

        // Fractional Seconds
        test_reformat_duration_passes_cedar("PT0.1S", "100ms");
        test_reformat_duration_passes_cedar("PT0.01S", "10ms");
        test_reformat_duration_passes_cedar("PT0.001S", "1ms");
        test_reformat_duration_passes_cedar("PT1.5S", "1s500ms");
        test_reformat_duration_passes_cedar("PT30.123456S", "30s123ms");
        test_reformat_duration_passes_cedar("PT1M30.5S", "1m30s500ms");
        test_reformat_duration_passes_cedar("PT1H30M45.999S", "1h30m45s999ms");
        test_reformat_duration_passes_cedar("P1DT12H30M15.123S", "1d12h30m15s123ms");

        // Zero Values
        test_reformat_duration_passes_cedar("P0D", "0ms");
        test_reformat_duration_passes_cedar("PT0H", "0ms");
        test_reformat_duration_passes_cedar("PT0M", "0ms");
        test_reformat_duration_passes_cedar("PT0S", "0ms");
        test_reformat_duration_passes_cedar("P0Y", "0ms");
        test_reformat_duration_passes_cedar("P0M", "0ms");
        test_reformat_duration_passes_cedar("P0W", "0d");

        // Large Values
        test_reformat_duration_passes_cedar("PT86400S", "86400s");
        test_reformat_duration_passes_cedar("PT1440M", "1440m");
        test_reformat_duration_passes_cedar("PT24H", "24h");
        test_reformat_duration_passes_cedar("P999D", "999d");
        test_reformat_duration_passes_cedar("P999Y", "364635d");
        test_reformat_duration_passes_cedar("PT999999S", "999999s");

        // Edge Cases
        test_reformat_duration_passes_cedar("P0DT0H0M0S", "0ms");
        test_reformat_duration_passes_cedar("PT0.000001S", "0ms");
        test_reformat_duration_passes_cedar("P1Y0M0DT0H0M0S", "365d");
        test_reformat_duration_passes_cedar("P0Y0M1DT0H0M0S", "1d");
        test_reformat_duration_passes_cedar("PT0.999999999S", "999ms");
    }

    fn test_reformat_ipaddr_passes_cedar(input: &str, expected: &str) {
        assert_eq!(reformat_ipaddr(input), expected);
        let expr: RestrictedExpr = format!("ip(\"{}\")", expected).parse().expect(&format!(
            "reformat_ipaddr({}) == {}, but ip(\"{}\") does not parse in Cedar",
            input, expected, expected
        ));
        let entities = Entities::new();
        let evaluator = cedar_policy_core::evaluator::Evaluator::new(
            cedar_policy_core::ast::Request::new(
                (EntityUID::from_str("P::\"\"").unwrap(), None),
                (EntityUID::from_str("Action::\"\"").unwrap(), None),
                (EntityUID::from_str("R::\"\"").unwrap(), None),
                Context::empty(),
                None::<&ValidatorSchema>,
                cedar_policy_core::extensions::Extensions::all_available(),
            )
            .unwrap(),
            &entities,
            cedar_policy_core::extensions::Extensions::all_available(),
        );
        evaluator.interpret(&expr, &HashMap::new()).expect(&format!(
            "reformat_ipaddr({}) == {}, but ip(\"{}\") evaluates to an error in Cedar",
            input, expected, expected
        ));
    }

    #[test]
    fn test_reformat_ipaddr() {
        // IPV4 Addresses
        test_reformat_ipaddr_passes_cedar("192.168.1.1", "192.168.1.1");
        test_reformat_ipaddr_passes_cedar("10.0.0.1", "10.0.0.1");
        test_reformat_ipaddr_passes_cedar("172.16.0.5", "172.16.0.5");
        test_reformat_ipaddr_passes_cedar("8.8.8.8", "8.8.8.8");
        test_reformat_ipaddr_passes_cedar("1.1.1.1", "1.1.1.1");
        test_reformat_ipaddr_passes_cedar("127.0.0.1", "127.0.0.1");
        test_reformat_ipaddr_passes_cedar("0.0.0.0", "0.0.0.0");
        test_reformat_ipaddr_passes_cedar("255.255.255.255", "255.255.255.255");

        // IPV4 Addresses with CIDR
        test_reformat_ipaddr_passes_cedar("192.168.1.0/24", "192.168.1.0/24");
        test_reformat_ipaddr_passes_cedar("10.0.0.0/8", "10.0.0.0/8");
        test_reformat_ipaddr_passes_cedar("172.16.0.0/12", "172.16.0.0/12");
        test_reformat_ipaddr_passes_cedar("0.0.0.0/0", "0.0.0.0/0");
        test_reformat_ipaddr_passes_cedar("192.0.2.0/24", "192.0.2.0/24");
        test_reformat_ipaddr_passes_cedar("198.51.100.0/24", "198.51.100.0/24");
        test_reformat_ipaddr_passes_cedar("203.0.113.0/24", "203.0.113.0/24");

        // IPV6 Addresses
        test_reformat_ipaddr_passes_cedar(
            "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
            "2001:db8:85a3::8a2e:370:7334",
        );
        test_reformat_ipaddr_passes_cedar("2001:db8::1", "2001:db8::1");
        test_reformat_ipaddr_passes_cedar("2001:db8:abcd:0012::10", "2001:db8:abcd:12::10");
        test_reformat_ipaddr_passes_cedar("2001:db8::", "2001:db8::");
        test_reformat_ipaddr_passes_cedar("2001:db8:0:0:0:0:2:1", "2001:db8::2:1");
        test_reformat_ipaddr_passes_cedar("fe80::1", "fe80::1");
        test_reformat_ipaddr_passes_cedar("fe80::1234:abcd", "fe80::1234:abcd");
        test_reformat_ipaddr_passes_cedar("::1", "::1");
        test_reformat_ipaddr_passes_cedar("::", "::");
        test_reformat_ipaddr_passes_cedar("::ffff", "::ffff");
        test_reformat_ipaddr_passes_cedar("ff02::1", "ff02::1");
        test_reformat_ipaddr_passes_cedar("ff02::2", "ff02::2");
        test_reformat_ipaddr_passes_cedar("ff05::1:3", "ff05::1:3");
        test_reformat_ipaddr_passes_cedar("fd00::1", "fd00::1");
        test_reformat_ipaddr_passes_cedar("fc00::abcd", "fc00::abcd");

        // IPV6 Addresses with CIDR
        test_reformat_ipaddr_passes_cedar("2001:db8::/32", "2001:db8::/32");
        test_reformat_ipaddr_passes_cedar("2001:db8:abcd::/48", "2001:db8:abcd::/48");
        test_reformat_ipaddr_passes_cedar("fe80::/10", "fe80::/10");
        test_reformat_ipaddr_passes_cedar("ff00::/8", "ff00::/8");
        test_reformat_ipaddr_passes_cedar("fd00::/8", "fd00::/8");
        test_reformat_ipaddr_passes_cedar("::1/128", "::1/128");
        test_reformat_ipaddr_passes_cedar("::/0", "::/0");
        test_reformat_ipaddr_passes_cedar("2001:db8:85a3::/64", "2001:db8:85a3::/64");

        // IPV6 addresses with embedded IPV4 address
        test_reformat_ipaddr_passes_cedar("::ffff:192.168.1.1", "192.168.1.1");
        test_reformat_ipaddr_passes_cedar("::ffff:10.0.0.1", "10.0.0.1");
        test_reformat_ipaddr_passes_cedar("::ffff:172.16.0.5", "172.16.0.5");
        test_reformat_ipaddr_passes_cedar("::ffff:8.8.8.8", "8.8.8.8");
        test_reformat_ipaddr_passes_cedar("::192.168.1.1", "::c0a8:101");
        test_reformat_ipaddr_passes_cedar("::10.0.0.1", "::a00:1");
        test_reformat_ipaddr_passes_cedar("::172.16.0.5", "::ac10:5");
        test_reformat_ipaddr_passes_cedar("::8.8.8.8", "::808:808");

        // More IPV6 Addresses
        test_reformat_ipaddr_passes_cedar("fe80::", "fe80::");
        test_reformat_ipaddr_passes_cedar("fe80::20c:29ff:fe9d:1a2b", "fe80::20c:29ff:fe9d:1a2b");
        test_reformat_ipaddr_passes_cedar("fe80::a1b2:c3d4:e5f6", "fe80::a1b2:c3d4:e5f6");
        test_reformat_ipaddr_passes_cedar("fd12:3456:789a::1", "fd12:3456:789a::1");
        test_reformat_ipaddr_passes_cedar("fd00:aaaa:bbbb:cccc::1", "fd00:aaaa:bbbb:cccc::1");
        test_reformat_ipaddr_passes_cedar("fc00:1234::abcd", "fc00:1234::abcd");
        test_reformat_ipaddr_passes_cedar("fdff:ffff:ffff:ffff::", "fdff:ffff:ffff:ffff::");
    }

    fn get_schema_generator(config: SchemaGeneratorConfig) -> SchemaGenerator {
        let schema_stub = r#"namespace Test {
    @mcp_principal("User")
    entity user;

    @mcp_resource("McpServer")
    entity resource;
}"#;
        let schema_stub =
            cedar_policy_core::validator::json_schema::Fragment::from_cedarschema_str(
                schema_stub,
                cedar_policy_core::extensions::Extensions::all_available(),
            )
            .expect("Failed to parse schema")
            .0;

        SchemaGenerator::new_with_config(schema_stub, config)
            .expect("Failed to create schema generator")
    }

    fn test_value_to_cedar_is_expr(
        val: &TypedValue,
        expected_expr: &RestrictedExpr,
        expected_entities: &Entities,
    ) {
        let request_generator = get_schema_generator(SchemaGeneratorConfig::default())
            .new_request_generator()
            .expect("Failed to construct request generator");

        let type_defs = TypeDefsInfo::new();
        let namespace = Some("Test".parse().unwrap());
        let (expr, entities) = request_generator
            .val_to_cedar(val, &type_defs, namespace.as_ref(), "test_type")
            .expect(&format!(
                "Failed to convert {:?} to Cedar expression and entities",
                val
            ));
        assert_eq!(
            &expr, expected_expr,
            "{:?} produced expression {} but expected {}",
            val, expr, expected_expr
        );
        assert_eq!(
            &entities, expected_entities,
            "{:?} produced entities {} but expected {}",
            val, entities, expected_entities
        );
    }

    fn str_to_number(s: &str) -> mcp_tools_sdk::data::Number {
        let input = mcp_tools_sdk::data::Input::from_json_str(&format!(
            r#"{{
    "params": {{
        "tool": "test_tool",
        "args": {{
            "arg": {}
        }}
    }}
}}"#,
            s
        ))
        .unwrap();
        input.get_arg("arg").unwrap().get_number().unwrap()
    }

    #[test]
    fn test_val_to_cedar() {
        test_value_to_cedar_is_expr(
            &TypedValue::Null,
            &RestrictedExpr::from_str("Test::Null::\"null\"").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Bool(true),
            &RestrictedExpr::val(true),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Bool(false),
            &RestrictedExpr::val(false),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Integer(123),
            &RestrictedExpr::val(123),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Integer(-12),
            &RestrictedExpr::val(-12),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Integer(0),
            &RestrictedExpr::val(0),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Float(0.0),
            &RestrictedExpr::from_str("Test::Float::\"0\"").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Float(1.01),
            &RestrictedExpr::from_str("Test::Float::\"1.01\"").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Float(-1.05),
            &RestrictedExpr::from_str("Test::Float::\"-1.05\"").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Number(str_to_number("0.0")),
            &RestrictedExpr::from_str("Test::Number::\"0.0\"").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Number(str_to_number("1.01")),
            &RestrictedExpr::from_str("Test::Number::\"1.01\"").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Number(str_to_number("-1.05")),
            &RestrictedExpr::from_str("Test::Number::\"-1.05\"").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::String("Some text".to_smolstr()),
            &RestrictedExpr::val("Some text"),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Decimal("0.0".to_smolstr()),
            &RestrictedExpr::from_str("decimal(\"0.0\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Decimal("-0.001".to_smolstr()),
            &RestrictedExpr::from_str("decimal(\"-0.001\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Decimal("10.0001".to_smolstr()),
            &RestrictedExpr::from_str("decimal(\"10.0001\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Datetime("2025-10-12".to_smolstr()),
            &RestrictedExpr::from_str("datetime(\"2025-10-12\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Datetime("2025-10-12T12:00:00+10:11".to_smolstr()),
            &RestrictedExpr::from_str("datetime(\"2025-10-12T12:00:00+1011\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Datetime("2025-10-12T12:00:00".to_smolstr()),
            &RestrictedExpr::from_str("datetime(\"2025-10-12T12:00:00Z\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Duration("P5W".to_smolstr()),
            &RestrictedExpr::from_str("duration(\"35d\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::IpAddr("10.0.0.1".to_smolstr()),
            &RestrictedExpr::from_str("ip(\"10.0.0.1\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::IpAddr("::1/24".to_smolstr()),
            &RestrictedExpr::from_str("ip(\"::1/24\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::IpAddr("::ffff:10.0.0.1".to_smolstr()),
            &RestrictedExpr::from_str("ip(\"10.0.0.1\")").unwrap(),
            &Entities::new(),
        );

        test_value_to_cedar_is_expr(
            &TypedValue::Enum("MyVariant".to_smolstr()),
            &RestrictedExpr::from_str("Test::test_type::\"MyVariant\"").unwrap(),
            &Entities::new(),
        );
    }

    // For these tests, just use single tool description
    fn get_request_generator(
        config: SchemaGeneratorConfig,
        tool_description: &str,
    ) -> RequestGenerator {
        let mut schema_generator = get_schema_generator(config);
        let tool_description = ToolDescription::from_json_str(tool_description)
            .expect("Failed to parse tool description");
        schema_generator
            .add_action_from_tool_description(&tool_description)
            .expect("Failed to add tool to schema generator");
        schema_generator
            .new_request_generator()
            .expect("Failed to construct request generator")
    }

    #[test]
    fn test_generate_request_default_config_empty_input() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default(),
            r#"{
    "name": "test_tool",
    "description": "test_description",
    "parameters": {
        "properties": {
        },
        "required": []
    }
}"#,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {}
    }
}"#,
        )
        .expect("Failed to parse input");

        let output = Output::from_json_str(
            r#"{
    "result": {
        "structuredContent": {}
    }
}"#,
        )
        .expect("Failed to parse output");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                Some(&output),
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert_eq!(entities, Entities::new());

        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 1 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if ikvs.len() == 0)
        });
    }

    #[test]
    fn test_generate_request_numbers_as_decimal() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default().encode_numbers_as_decimal(true),
            r#"{
    "name": "test_tool",
    "description": "test_description",
    "parameters": {
        "properties": {
            "num_attr": {
                "type": "number"
            },
            "float_attr": {
                "type": "float"
            },
            "pseudo_int": {
                "type": "number"
            },
            "int_attr": {
                "type": "integer"
            }
        },
        "required": ["num_attr", "float_attr"]
    }
}"#,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {
            "num_attr": 0.01,
            "float_attr": -0.01,
            "pseudo_int": 10
        }
    }
}"#,
        )
        .expect("Failed to parse input");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                None,
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert_eq!(entities, Entities::new());

        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 1 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 3 &&
                matches!(map.get("num_attr").map(Value::value_kind), Some(ValueKind::ExtensionValue(dval)) if
                    RestrictedExpr::from((**dval).clone()) == RestrictedExpr::from_str("decimal(\"0.0100\")").unwrap()
                ) &&
                matches!(map.get("float_attr").map(Value::value_kind), Some(ValueKind::ExtensionValue(dval)) if
                    RestrictedExpr::from((**dval).clone()) == RestrictedExpr::from_str("decimal(\"-0.0100\")").unwrap()
                ) &&
                matches!(map.get("pseudo_int").map(Value::value_kind), Some(ValueKind::ExtensionValue(dval)) if
                    RestrictedExpr::from((**dval).clone()) == RestrictedExpr::from_str("decimal(\"10.0\")").unwrap()
                )
            })
        });
    }

    #[test]
    fn test_generate_request_default_config_unknown_property_types() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default(),
            r#"{
    "name": "test_tool",
    "description": "test_description",
    "parameters": {
        "properties": {
            "unknown1": {},
            "unknown2": {}
        },
        "required": []
    }
}"#,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {
            "unknown1": true,
            "unknown2": [0.01, {}, []]
        }
    }
}"#,
        )
        .expect("Failed to parse input");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                None,
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert_eq!(entities, Entities::new());
        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 1 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 2 &&
                matches!(map.get("unknown1").map(Value::value_kind), Some(ValueKind::Lit(Literal::EntityUID(..)))) &&
                matches!(map.get("unknown2").map(Value::value_kind), Some(ValueKind::Lit(Literal::EntityUID(..)))) &&
                map.get("unknown1") != map.get("unknown2")
            })
        });
    }

    #[test]
    fn test_generate_request_default_config_array() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default(),
            r#"{
    "name": "test_tool",
    "description": "test_description",
    "parameters": {
        "properties": {
            "arr_attr": {
                "type": "array",
                "items": {
                    "type": "boolean"
                }
            }
        },
        "required": ["arr_attr"]
    }
}"#,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {
            "arr_attr": [true, false]
        }
    }
}"#,
        )
        .expect("Failed to parse input");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                None,
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert_eq!(entities, Entities::new());
        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 1 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 1 &&
                matches!(map.get("arr_attr").map(Value::value_kind), Some(ValueKind::Set(s)) if {
                    s.len() == 2 &&
                    s.contains(&Value::new(true, None)) &&
                    s.contains(&Value::new(false, None))

                })
            })
        });
    }

    #[test]
    fn test_generate_request_default_config_tuple() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default(),
            r#"{
    "name": "test_tool",
    "description": "test_description",
    "parameters": {
        "properties": {
            "tuple_attr": {
                "type": ["boolean", "integer"]
            }
        }
    }
}"#,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {
            "tuple_attr": [true, 0]
        }
    }
}"#,
        )
        .expect("Failed to parse input");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                None,
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert_eq!(entities, Entities::new());
        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 1 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 1 &&
                matches!(map.get("tuple_attr").map(Value::value_kind), Some(ValueKind::Record(iikvs)) if {
                    let map = &**iikvs;
                    map.len() == 2 &&
                    matches!(map.get("proj0").map(Value::value_kind), Some(ValueKind::Lit(Literal::Bool(true)))) &&
                    matches!(map.get("proj1").map(Value::value_kind), Some(ValueKind::Lit(Literal::Long(0))))
                })
            })
        });
    }

    #[test]
    fn test_generate_request_default_config_union() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default(),
            r#"{
    "name": "test_tool",
    "description": "test_description",
    "parameters": {
        "properties": {
            "union_attr": {
                "anyOf": [
                    { "type": "boolean" },
                    { "type": "integer" }
                ]
            }
        }
    }
}"#,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {
            "union_attr": 0
        }
    }
}"#,
        )
        .expect("Failed to parse input");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                None,
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert_eq!(entities, Entities::new());
        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 1 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 1 &&
                matches!(map.get("union_attr").map(Value::value_kind), Some(ValueKind::Record(iikvs)) if {
                    let map = &**iikvs;
                    map.len() == 1 &&
                    matches!(map.get("typeChoice1").map(Value::value_kind), Some(ValueKind::Lit(Literal::Long(0))))
                })
            })
        });
    }

    #[test]
    fn test_generate_request_default_config_ref_of_object() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default(),
            r##"{
    "name": "test_tool",
    "description": "test_description",
    "parameters": {
        "$defs": {
            "MyObject": {
                "type": "object",
                "properties": {
                    "enum": {
                        "type": "string",
                        "enum": ["hi", "med", "low"]
                    }
                }
            }
        },
        "properties": {
            "ref_attr": {
                "$ref": "#/$defs/MyObject"
            }
        }
    }
}"##,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {
            "ref_attr": {
                "enum": "hi"
            }
        }
    }
}"#,
        )
        .expect("Failed to parse input");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                None,
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert!(
            entities.len() == 1,
            "{:?}\n{:?}",
            entities,
            request.context()
        );
        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 1 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 1 &&
                matches!(map.get("ref_attr").map(Value::value_kind), Some(ValueKind::Lit(Literal::EntityUID(eid))) if {
                    matches!(entities.entity(eid), Dereference::Data(e) if {
                        let attrs = e.attrs().collect::<HashMap<_,_>>();
                        attrs.len() == 1 &&
                        matches!(attrs.get(&"enum".to_smolstr()), Some(PartialValue::Value(v)) if {
                            matches!(v.value_kind(), ValueKind::Lit(Literal::EntityUID(eid)) if {
                                **eid == "Test::test_tool::Input::MyObject::enum::\"hi\"".parse().expect("Failed to parse EID")
                            })
                        })
                    })
                })
            })
        });
    }

    #[test]
    fn test_generate_request_flatten_namespaces_ref_of_object_with_enum() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default().flatten_namespaces(true),
            r##"{
    "name": "test_tool",
    "description": "test_description",
    "parameters": {
        "$defs": {
            "MyObject": {
                "type": "object",
                "properties": {
                    "enum": {
                        "type": "string",
                        "enum": ["hi", "med", "low"]
                    }
                }
            }
        },
        "properties": {
            "ref_attr": {
                "$ref": "#/$defs/MyObject"
            }
        }
    }
}"##,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {
            "ref_attr": {
                "enum": "hi"
            }
        }
    }
}"#,
        )
        .expect("Failed to parse input");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                None,
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert!(
            entities.len() == 1,
            "{:?}\n{:?}",
            entities,
            request.context()
        );
        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 1 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 1 &&
                matches!(map.get("ref_attr").map(Value::value_kind), Some(ValueKind::Lit(Literal::EntityUID(eid))) if {
                    matches!(entities.entity(eid), Dereference::Data(e) if {
                        let attrs = e.attrs().collect::<HashMap<_,_>>();
                        attrs.len() == 1 &&
                        matches!(attrs.get(&"enum".to_smolstr()), Some(PartialValue::Value(v)) if {
                            matches!(v.value_kind(), ValueKind::Lit(Literal::EntityUID(eid)) if {
                                **eid == "Test::test_tool_Input_MyObject_enum::\"hi\"".parse().expect("Failed to parse EID")
                            })
                        })
                    })
                })
            })
        });
    }

    #[test]
    fn test_generate_request_object_as_record_and_flatten_namespaces_ref_of_object_with_enum() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default()
                .objects_as_records(true)
                .flatten_namespaces(true),
            r##"{
    "name": "test_tool",
    "description": "test_description",
    "parameters": {
        "$defs": {
            "MyObject": {
                "type": "object",
                "properties": {
                    "enum": {
                        "type": "string",
                        "enum": ["hi", "med", "low"]
                    }
                }
            }
        },
        "properties": {
            "ref_attr": {
                "$ref": "#/$defs/MyObject"
            }
        }
    }
}"##,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {
            "ref_attr": {
                "enum": "hi"
            }
        }
    }
}"#,
        )
        .expect("Failed to parse input");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                None,
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert_eq!(entities, Entities::new());
        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 1 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 1 &&
                matches!(map.get("ref_attr").map(Value::value_kind), Some(ValueKind::Record(iikvs)) if {
                    let map = &**iikvs;
                    map.len() == 1 &&
                    matches!(map.get("enum").map(Value::value_kind), Some(ValueKind::Lit(Literal::EntityUID(eid))) if {
                        **eid == "Test::test_tool_Input_MyObject_enum::\"hi\"".parse().expect("Failed to parse EID")
                    })
                })
            })
        });
    }

    #[test]
    fn test_generate_request_include_outputs() {
        let request_generator = get_request_generator(
            SchemaGeneratorConfig::default().include_outputs(true),
            r#"{
    "name": "test_tool",
    "description": "test_description",
    "inputSchema": {
        "properties": {
            "in_attr": {
                "type": "boolean"
            }
        }
    },
    "outputSchema": {
        "properties": {
            "out_attr": {
                "type": "integer"
            }
        }
    }
}"#,
        );

        let input = Input::from_json_str(
            r#"{
    "params": {
        "tool": "test_tool",
        "args": {
            "in_attr": true
        }
    }
}"#,
        )
        .expect("Failed to parse input");

        let output = Output::from_json_str(
            r#"{
    "result": {
        "structuredContent": {
            "out_attr": 1
        }
    }
}"#,
        )
        .expect("Failed to parse output");

        let principal = r#"Test::user::"""#.parse::<EntityUID>().unwrap();
        let resource = r#"Test::resource::"""#.parse::<EntityUID>().unwrap();

        let (request, entities) = request_generator
            .generate_request(
                principal.clone(),
                resource.clone(),
                Context::empty(),
                Entities::new(),
                &input,
                Some(&output),
            )
            .expect("Failed to generate request");

        assert_eq!(request.principal().uid().unwrap(), &principal);
        assert_eq!(
            request.action().uid().unwrap(),
            &r#"Test::Action::"test_tool""#.parse::<EntityUID>().unwrap()
        );
        assert_eq!(request.resource().uid().unwrap(), &resource);
        assert_eq!(entities, Entities::new());
        assert_matches!(request.context(), Some(Context::Value(kvs)) if {
            let map = &**kvs;
            map.len() == 2 &&
            matches!(map.get("input").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 1 &&
                matches!(map.get("in_attr").map(Value::value_kind), Some(ValueKind::Lit(Literal::Bool(true))))
            }) &&
            matches!(map.get("output").map(Value::value_kind), Some(ValueKind::Record(ikvs)) if {
                let map = &**ikvs;
                map.len() == 1 &&
                matches!(map.get("out_attr").map(Value::value_kind), Some(ValueKind::Lit(Literal::Long(1))))
            })
        });
    }
}
